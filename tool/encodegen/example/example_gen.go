// Code generated by github.com/yutakahashi114/isutool; DO NOT EDIT.
package example

import (
	"encoding/binary"
	"errors"
	"math"
	"time"

	other "github.com/yutakahashi114/isutool/tool/encodegen/example/other"
	example "github.com/yutakahashi114/isutool/tool/encodegen/example/other/unpointer"
)

var (
	_ = math.MaxUint8
)

func (f *FixedLength) Encode() ([]byte, error) {
	out := make([]byte, f.MaxSize())

	_n, err := f.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (f *FixedLength) Decode(in []byte) (*FixedLength, error) {
	_, err := DecodeFixedLength(in, f)
	if err != nil {
		return f, err
	}

	return f, nil
}

func (f *FixedLength) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if f != nil {
		// Int8
		_size += 1
		// Int16
		_size += binary.MaxVarintLen16
		// Int32
		_size += binary.MaxVarintLen32
		// Int64
		_size += binary.MaxVarintLen64
		// Int
		_size += binary.MaxVarintLen64
		// Uint8
		_size += 1
		// Uint16
		_size += binary.MaxVarintLen16
		// Uint32
		_size += binary.MaxVarintLen32
		// Uint64
		_size += binary.MaxVarintLen64
		// Uint
		_size += binary.MaxVarintLen64
		// Float32
		_size += binary.MaxVarintLen32
		// Float64
		_size += binary.MaxVarintLen64
		// Byte
		_size += 1
		// Rune
		_size += binary.MaxVarintLen32
		// Bool
		_size += 1
		// Time
		_size += 16
	}
	return _size
}

func (f *FixedLength) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if f == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Int8
		out[_n] = byte((*f).Int8)
		_n += 1
		// Int16
		_n += binary.PutVarint(out[_n:], int64((*f).Int16))
		// Int32
		_n += binary.PutVarint(out[_n:], int64((*f).Int32))
		// Int64
		_n += binary.PutVarint(out[_n:], int64((*f).Int64))
		// Int
		_n += binary.PutVarint(out[_n:], int64((*f).Int))
		// Uint8
		out[_n] = byte((*f).Uint8)
		_n += 1
		// Uint16
		_n += binary.PutUvarint(out[_n:], uint64((*f).Uint16))
		// Uint32
		_n += binary.PutUvarint(out[_n:], uint64((*f).Uint32))
		// Uint64
		_n += binary.PutUvarint(out[_n:], uint64((*f).Uint64))
		// Uint
		_n += binary.PutUvarint(out[_n:], uint64((*f).Uint))
		// Float32
		_n += binary.PutUvarint(out[_n:], uint64(math.Float32bits((*f).Float32)))
		// Float64
		_n += binary.PutUvarint(out[_n:], uint64(math.Float64bits((*f).Float64)))
		// Byte
		out[_n] = byte((*f).Byte)
		_n += 1
		// Rune
		_n += binary.PutVarint(out[_n:], int64((*f).Rune))
		// Bool
		if (*f).Bool {
			out[_n] = 1
		} else {
			out[_n] = 0
		}
		_n += 1
		// Time
		ƒçfå_Time, err := _timeMarshalBinary((*f).Time, out[_n:])
		if err != nil {
			return 0, err
		}
		_n += ƒçfå_Time

	}

	return _n, nil
}

func DecodeFixedLength(in []byte, f *FixedLength) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Int8
	(*f).Int8 = int8(in[_n])
	_n += 1
	// Int16
	_ƒçfå_Int16, _ƒçfå_Int16Size := binary.Varint(in[_n:])
	(*f).Int16 = int16(_ƒçfå_Int16)
	_n += _ƒçfå_Int16Size
	// Int32
	_ƒçfå_Int32, _ƒçfå_Int32Size := binary.Varint(in[_n:])
	(*f).Int32 = int32(_ƒçfå_Int32)
	_n += _ƒçfå_Int32Size
	// Int64
	_ƒçfå_Int64, _ƒçfå_Int64Size := binary.Varint(in[_n:])
	(*f).Int64 = int64(_ƒçfå_Int64)
	_n += _ƒçfå_Int64Size
	// Int
	_ƒçfå_Int, _ƒçfå_IntSize := binary.Varint(in[_n:])
	(*f).Int = int(_ƒçfå_Int)
	_n += _ƒçfå_IntSize
	// Uint8
	(*f).Uint8 = uint8(in[_n])
	_n += 1
	// Uint16
	_ƒçfå_Uint16, _ƒçfå_Uint16Size := binary.Uvarint(in[_n:])
	(*f).Uint16 = uint16(_ƒçfå_Uint16)
	_n += _ƒçfå_Uint16Size
	// Uint32
	_ƒçfå_Uint32, _ƒçfå_Uint32Size := binary.Uvarint(in[_n:])
	(*f).Uint32 = uint32(_ƒçfå_Uint32)
	_n += _ƒçfå_Uint32Size
	// Uint64
	_ƒçfå_Uint64, _ƒçfå_Uint64Size := binary.Uvarint(in[_n:])
	(*f).Uint64 = uint64(_ƒçfå_Uint64)
	_n += _ƒçfå_Uint64Size
	// Uint
	_ƒçfå_Uint, _ƒçfå_UintSize := binary.Uvarint(in[_n:])
	(*f).Uint = uint(_ƒçfå_Uint)
	_n += _ƒçfå_UintSize
	// Float32
	_ƒçfå_Float32, _ƒçfå_Float32Size := binary.Uvarint(in[_n:])
	(*f).Float32 = float32(math.Float32frombits(uint32(_ƒçfå_Float32)))
	_n += _ƒçfå_Float32Size
	// Float64
	_ƒçfå_Float64, _ƒçfå_Float64Size := binary.Uvarint(in[_n:])
	(*f).Float64 = float64(math.Float64frombits(_ƒçfå_Float64))
	_n += _ƒçfå_Float64Size
	// Byte
	(*f).Byte = byte(in[_n])
	_n += 1
	// Rune
	_ƒçfå_Rune, _ƒçfå_RuneSize := binary.Varint(in[_n:])
	(*f).Rune = rune(_ƒçfå_Rune)
	_n += _ƒçfå_RuneSize
	// Bool
	if in[_n] == 1 {
		(*f).Bool = true
	} else {
		(*f).Bool = false
	}
	_n += 1
	// Time
	if in[_n] == 1 {
		err = (*f).Time.UnmarshalBinary(in[_n : _n+15])
	} else {
		err = (*f).Time.UnmarshalBinary(in[_n : _n+16])
	}
	if err != nil {
		return 0, err
	}
	_n += 16

	return _n, nil
}

func (s *String) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *String) Decode(in []byte) (*String, error) {
	_, err := DecodeString(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *String) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		// Str
		_size += binary.MaxVarintLen64 + len((*s).Str)
		// Bytes
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Bytes {
			_ = _e
			_size += 1
		}
		// Runes
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Runes {
			_ = _e
			_size += binary.MaxVarintLen32
		}
	}
	return _size
}

func (s *String) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*s).Str)))
		_n += copy(out[_n:], (*s).Str)
		// Bytes
		if (*s).Bytes == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Bytes)))
			for _, _e := range (*s).Bytes {
				_ = _e
				out[_n] = byte(_e)
				_n += 1
			}
		}
		// Runes
		if (*s).Runes == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Runes)))
			for _, _e := range (*s).Runes {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(_e))
			}
		}

	}

	return _n, nil
}

func DecodeString(in []byte, s *String) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Str
	_ƒçså_StrLen, _ƒçså_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçså_StrLenSize
	(*s).Str = string(in[_n : _n+int(_ƒçså_StrLen)])
	_n += int(_ƒçså_StrLen)
	// Bytes
	if in[_n] == 0 {
		_n += 1
		(*s).Bytes = nil
	} else {
		_n += 1
		_ƒçså_BytesLen, _ƒçså_BytesLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_BytesLenSize
		(*s).Bytes = make([]byte, _ƒçså_BytesLen)
		for _i := int64(0); _i < _ƒçså_BytesLen; _i++ {
			var _e_ƒçså_Bytes byte
			_e_ƒçså_Bytes = byte(in[_n])
			_n += 1
			(*s).Bytes[_i] = _e_ƒçså_Bytes
		}
	}
	// Runes
	if in[_n] == 0 {
		_n += 1
		(*s).Runes = nil
	} else {
		_n += 1
		_ƒçså_RunesLen, _ƒçså_RunesLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_RunesLenSize
		(*s).Runes = make([]rune, _ƒçså_RunesLen)
		for _i := int64(0); _i < _ƒçså_RunesLen; _i++ {
			var _e_ƒçså_Runes rune
			__e_ƒçså_Runes, __e_ƒçså_RunesSize := binary.Varint(in[_n:])
			_e_ƒçså_Runes = rune(__e_ƒçså_Runes)
			_n += __e_ƒçså_RunesSize
			(*s).Runes[_i] = _e_ƒçså_Runes
		}
	}

	return _n, nil
}

func (p *Pointer) Encode() ([]byte, error) {
	out := make([]byte, p.MaxSize())

	_n, err := p.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (p *Pointer) Decode(in []byte) (*Pointer, error) {
	_, err := DecodePointer(in, p)
	if err != nil {
		return p, err
	}

	return p, nil
}

func (p *Pointer) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if p != nil {
		// Pint
		_size += 1 // is nil
		if (*p).Pint != nil {
			_size += binary.MaxVarintLen64
		}
		// Pstr
		_size += 1 // is nil
		if (*p).Pstr != nil {
			_size += binary.MaxVarintLen64 + len((*(*p).Pstr))
		}
		// Pstruct
		_size += 1 // is nil
		if (*p).Pstruct != nil {
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len((*(*p).Pstruct).Str)
			// Pint
			_size += 1 // is nil
			if (*(*p).Pstruct).Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range (*(*p).Pstruct).Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range (*(*p).Pstruct).StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}
		}
		// Ppint
		_size += 1 // is nil
		if (*p).Ppint != nil {
			_size += 1 // is nil
			if (*(*p).Ppint) != nil {
				_size += binary.MaxVarintLen64
			}
		}
	}
	return _size
}

func (p *Pointer) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if p == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Pint
		if (*p).Pint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64((*(*p).Pint)))
		}
		// Pstr
		if (*p).Pstr == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*(*p).Pstr))))
			_n += copy(out[_n:], (*(*p).Pstr))
		}
		// Pstruct
		if (*p).Pstruct == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			// Int
			_n += binary.PutVarint(out[_n:], int64((*(*p).Pstruct).Int))
			// Str
			_n += binary.PutVarint(out[_n:], int64(len((*(*p).Pstruct).Str)))
			_n += copy(out[_n:], (*(*p).Pstruct).Str)
			// Pint
			if (*(*p).Pstruct).Pint == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64((*(*(*p).Pstruct).Pint)))
			}
			// Strs
			if (*(*p).Pstruct).Strs == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64(len((*(*p).Pstruct).Strs)))
				for _, _e := range (*(*p).Pstruct).Strs {
					_ = _e
					_n += binary.PutVarint(out[_n:], int64(len(_e)))
					_n += copy(out[_n:], _e)
				}
			}
			// StrInt
			if (*(*p).Pstruct).StrInt == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64(len((*(*p).Pstruct).StrInt)))
				for _k, _v := range (*(*p).Pstruct).StrInt {
					_, _ = _k, _v
					_n += binary.PutVarint(out[_n:], int64(len(_k)))
					_n += copy(out[_n:], _k)
					_n += binary.PutVarint(out[_n:], int64(_v))
				}
			}

		}
		// Ppint
		if (*p).Ppint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			if (*(*p).Ppint) == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64((*(*(*p).Ppint))))
			}
		}

	}

	return _n, nil
}

func DecodePointer(in []byte, p *Pointer) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Pint
	if in[_n] == 0 {
		_n += 1
		(*p).Pint = nil
	} else {
		_n += 1
		var _p_ƒçpå_Pint int
		__p_ƒçpå_Pint, __p_ƒçpå_PintSize := binary.Varint(in[_n:])
		_p_ƒçpå_Pint = int(__p_ƒçpå_Pint)
		_n += __p_ƒçpå_PintSize
		(*p).Pint = &_p_ƒçpå_Pint
	}
	// Pstr
	if in[_n] == 0 {
		_n += 1
		(*p).Pstr = nil
	} else {
		_n += 1
		var _p_ƒçpå_Pstr string
		__p_ƒçpå_PstrLen, __p_ƒçpå_PstrLenSize := binary.Varint(in[_n:])
		_n += __p_ƒçpå_PstrLenSize
		_p_ƒçpå_Pstr = string(in[_n : _n+int(__p_ƒçpå_PstrLen)])
		_n += int(__p_ƒçpå_PstrLen)
		(*p).Pstr = &_p_ƒçpå_Pstr
	}
	// Pstruct
	if in[_n] == 0 {
		_n += 1
		(*p).Pstruct = nil
	} else {
		_n += 1
		var _p_ƒçpå_Pstruct TestStruct
		// Int
		__p_ƒçpå_Pstruct_Int, __p_ƒçpå_Pstruct_IntSize := binary.Varint(in[_n:])
		_p_ƒçpå_Pstruct.Int = int(__p_ƒçpå_Pstruct_Int)
		_n += __p_ƒçpå_Pstruct_IntSize
		// Str
		__p_ƒçpå_Pstruct_StrLen, __p_ƒçpå_Pstruct_StrLenSize := binary.Varint(in[_n:])
		_n += __p_ƒçpå_Pstruct_StrLenSize
		_p_ƒçpå_Pstruct.Str = string(in[_n : _n+int(__p_ƒçpå_Pstruct_StrLen)])
		_n += int(__p_ƒçpå_Pstruct_StrLen)
		// Pint
		if in[_n] == 0 {
			_n += 1
			_p_ƒçpå_Pstruct.Pint = nil
		} else {
			_n += 1
			var _p__p_ƒçpå_Pstruct_Pint int
			__p__p_ƒçpå_Pstruct_Pint, __p__p_ƒçpå_Pstruct_PintSize := binary.Varint(in[_n:])
			_p__p_ƒçpå_Pstruct_Pint = int(__p__p_ƒçpå_Pstruct_Pint)
			_n += __p__p_ƒçpå_Pstruct_PintSize
			_p_ƒçpå_Pstruct.Pint = &_p__p_ƒçpå_Pstruct_Pint
		}
		// Strs
		if in[_n] == 0 {
			_n += 1
			_p_ƒçpå_Pstruct.Strs = nil
		} else {
			_n += 1
			__p_ƒçpå_Pstruct_StrsLen, __p_ƒçpå_Pstruct_StrsLenSize := binary.Varint(in[_n:])
			_n += __p_ƒçpå_Pstruct_StrsLenSize
			_p_ƒçpå_Pstruct.Strs = make([]string, __p_ƒçpå_Pstruct_StrsLen)
			for _i := int64(0); _i < __p_ƒçpå_Pstruct_StrsLen; _i++ {
				var _e__p_ƒçpå_Pstruct_Strs string
				__e__p_ƒçpå_Pstruct_StrsLen, __e__p_ƒçpå_Pstruct_StrsLenSize := binary.Varint(in[_n:])
				_n += __e__p_ƒçpå_Pstruct_StrsLenSize
				_e__p_ƒçpå_Pstruct_Strs = string(in[_n : _n+int(__e__p_ƒçpå_Pstruct_StrsLen)])
				_n += int(__e__p_ƒçpå_Pstruct_StrsLen)
				_p_ƒçpå_Pstruct.Strs[_i] = _e__p_ƒçpå_Pstruct_Strs
			}
		}
		// StrInt
		if in[_n] == 0 {
			_n += 1
			_p_ƒçpå_Pstruct.StrInt = nil
		} else {
			_n += 1
			__p_ƒçpå_Pstruct_StrIntLen, __p_ƒçpå_Pstruct_StrIntLenSize := binary.Varint(in[_n:])
			_n += __p_ƒçpå_Pstruct_StrIntLenSize
			_p_ƒçpå_Pstruct.StrInt = make(map[string]int, __p_ƒçpå_Pstruct_StrIntLen)
			for _i := int64(0); _i < __p_ƒçpå_Pstruct_StrIntLen; _i++ {
				var _k__p_ƒçpå_Pstruct_StrInt string
				var _v__p_ƒçpå_Pstruct_StrInt int
				__k__p_ƒçpå_Pstruct_StrIntLen, __k__p_ƒçpå_Pstruct_StrIntLenSize := binary.Varint(in[_n:])
				_n += __k__p_ƒçpå_Pstruct_StrIntLenSize
				_k__p_ƒçpå_Pstruct_StrInt = string(in[_n : _n+int(__k__p_ƒçpå_Pstruct_StrIntLen)])
				_n += int(__k__p_ƒçpå_Pstruct_StrIntLen)
				__v__p_ƒçpå_Pstruct_StrInt, __v__p_ƒçpå_Pstruct_StrIntSize := binary.Varint(in[_n:])
				_v__p_ƒçpå_Pstruct_StrInt = int(__v__p_ƒçpå_Pstruct_StrInt)
				_n += __v__p_ƒçpå_Pstruct_StrIntSize
				_p_ƒçpå_Pstruct.StrInt[_k__p_ƒçpå_Pstruct_StrInt] = _v__p_ƒçpå_Pstruct_StrInt
			}
		}

		(*p).Pstruct = &_p_ƒçpå_Pstruct
	}
	// Ppint
	if in[_n] == 0 {
		_n += 1
		(*p).Ppint = nil
	} else {
		_n += 1
		var _p_ƒçpå_Ppint *int
		if in[_n] == 0 {
			_n += 1
			_p_ƒçpå_Ppint = nil
		} else {
			_n += 1
			var _p__p_ƒçpå_Ppint int
			__p__p_ƒçpå_Ppint, __p__p_ƒçpå_PpintSize := binary.Varint(in[_n:])
			_p__p_ƒçpå_Ppint = int(__p__p_ƒçpå_Ppint)
			_n += __p__p_ƒçpå_PpintSize
			_p_ƒçpå_Ppint = &_p__p_ƒçpå_Ppint
		}
		(*p).Ppint = &_p_ƒçpå_Ppint
	}

	return _n, nil
}

func (m *Map) Encode() ([]byte, error) {
	out := make([]byte, m.MaxSize())

	_n, err := m.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (m *Map) Decode(in []byte) (*Map, error) {
	_, err := DecodeMap(in, m)
	if err != nil {
		return m, err
	}

	return m, nil
}

func (m *Map) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if m != nil {
		// StrInt
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*m).StrInt {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
		}
		// StrIntStr
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*m).StrIntStr {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _v {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64
				_size += binary.MaxVarintLen64 + len(_v)
			}
		}
		// PointerStrInt
		_size += 1 // is nil
		if (*m).PointerStrInt != nil {
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range *(*m).PointerStrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}
		}
		// StructStruct
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*m).StructStruct {
			_, _ = _k, _v
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_k.Str)

			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_v.Str)
			// Pint
			_size += 1 // is nil
			if _v.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _v.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _v.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
		// StructPstruct
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*m).StructPstruct {
			_, _ = _k, _v
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_k.Str)

			_size += 1 // is nil
			if _v != nil {
				// Int
				_size += binary.MaxVarintLen64
				// Str
				_size += binary.MaxVarintLen64 + len((*_v).Str)
				// Pint
				_size += 1 // is nil
				if (*_v).Pint != nil {
					_size += binary.MaxVarintLen64
				}
				// Strs
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _, _e := range (*_v).Strs {
					_ = _e
					_size += binary.MaxVarintLen64 + len(_e)
				}
				// StrInt
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _k, _v := range (*_v).StrInt {
					_, _ = _k, _v
					_size += binary.MaxVarintLen64 + len(_k)
					_size += binary.MaxVarintLen64
				}
			}
		}
	}
	return _size
}

func (m *Map) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if m == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// StrInt
		if (*m).StrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).StrInt)))
			for _k, _v := range (*m).StrInt {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				_n += binary.PutVarint(out[_n:], int64(_v))
			}
		}
		// StrIntStr
		if (*m).StrIntStr == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).StrIntStr)))
			for _k, _v := range (*m).StrIntStr {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				if _v == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v)))
					for _k, _v := range _v {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(_k))
						_n += binary.PutVarint(out[_n:], int64(len(_v)))
						_n += copy(out[_n:], _v)
					}
				}
			}
		}
		// PointerStrInt
		if (*m).PointerStrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			if (*(*m).PointerStrInt) == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64(len((*(*m).PointerStrInt))))
				for _k, _v := range *(*m).PointerStrInt {
					_, _ = _k, _v
					_n += binary.PutVarint(out[_n:], int64(len(_k)))
					_n += copy(out[_n:], _k)
					_n += binary.PutVarint(out[_n:], int64(_v))
				}
			}
		}
		// StructStruct
		if (*m).StructStruct == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).StructStruct)))
			for _k, _v := range (*m).StructStruct {
				_, _ = _k, _v
				// Int
				_n += binary.PutVarint(out[_n:], int64(_k.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_k.Str)))
				_n += copy(out[_n:], _k.Str)

				// Int
				_n += binary.PutVarint(out[_n:], int64(_v.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_v.Str)))
				_n += copy(out[_n:], _v.Str)
				// Pint
				if _v.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_v.Pint)))
				}
				// Strs
				if _v.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.Strs)))
					for _, _e := range _v.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _v.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.StrInt)))
					for _k, _v := range _v.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}
		// StructPstruct
		if (*m).StructPstruct == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).StructPstruct)))
			for _k, _v := range (*m).StructPstruct {
				_, _ = _k, _v
				// Int
				_n += binary.PutVarint(out[_n:], int64(_k.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_k.Str)))
				_n += copy(out[_n:], _k.Str)

				if _v == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					// Int
					_n += binary.PutVarint(out[_n:], int64((*_v).Int))
					// Str
					_n += binary.PutVarint(out[_n:], int64(len((*_v).Str)))
					_n += copy(out[_n:], (*_v).Str)
					// Pint
					if (*_v).Pint == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64((*(*_v).Pint)))
					}
					// Strs
					if (*_v).Strs == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_v).Strs)))
						for _, _e := range (*_v).Strs {
							_ = _e
							_n += binary.PutVarint(out[_n:], int64(len(_e)))
							_n += copy(out[_n:], _e)
						}
					}
					// StrInt
					if (*_v).StrInt == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_v).StrInt)))
						for _k, _v := range (*_v).StrInt {
							_, _ = _k, _v
							_n += binary.PutVarint(out[_n:], int64(len(_k)))
							_n += copy(out[_n:], _k)
							_n += binary.PutVarint(out[_n:], int64(_v))
						}
					}

				}
			}
		}

	}

	return _n, nil
}

func DecodeMap(in []byte, m *Map) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// StrInt
	if in[_n] == 0 {
		_n += 1
		(*m).StrInt = nil
	} else {
		_n += 1
		_ƒçmå_StrIntLen, _ƒçmå_StrIntLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_StrIntLenSize
		(*m).StrInt = make(map[string]int, _ƒçmå_StrIntLen)
		for _i := int64(0); _i < _ƒçmå_StrIntLen; _i++ {
			var _k_ƒçmå_StrInt string
			var _v_ƒçmå_StrInt int
			__k_ƒçmå_StrIntLen, __k_ƒçmå_StrIntLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçmå_StrIntLenSize
			_k_ƒçmå_StrInt = string(in[_n : _n+int(__k_ƒçmå_StrIntLen)])
			_n += int(__k_ƒçmå_StrIntLen)
			__v_ƒçmå_StrInt, __v_ƒçmå_StrIntSize := binary.Varint(in[_n:])
			_v_ƒçmå_StrInt = int(__v_ƒçmå_StrInt)
			_n += __v_ƒçmå_StrIntSize
			(*m).StrInt[_k_ƒçmå_StrInt] = _v_ƒçmå_StrInt
		}
	}
	// StrIntStr
	if in[_n] == 0 {
		_n += 1
		(*m).StrIntStr = nil
	} else {
		_n += 1
		_ƒçmå_StrIntStrLen, _ƒçmå_StrIntStrLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_StrIntStrLenSize
		(*m).StrIntStr = make(map[string]map[int]string, _ƒçmå_StrIntStrLen)
		for _i := int64(0); _i < _ƒçmå_StrIntStrLen; _i++ {
			var _k_ƒçmå_StrIntStr string
			var _v_ƒçmå_StrIntStr map[int]string
			__k_ƒçmå_StrIntStrLen, __k_ƒçmå_StrIntStrLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçmå_StrIntStrLenSize
			_k_ƒçmå_StrIntStr = string(in[_n : _n+int(__k_ƒçmå_StrIntStrLen)])
			_n += int(__k_ƒçmå_StrIntStrLen)
			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StrIntStr = nil
			} else {
				_n += 1
				__v_ƒçmå_StrIntStrLen, __v_ƒçmå_StrIntStrLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçmå_StrIntStrLenSize
				_v_ƒçmå_StrIntStr = make(map[int]string, __v_ƒçmå_StrIntStrLen)
				for _i := int64(0); _i < __v_ƒçmå_StrIntStrLen; _i++ {
					var _k__v_ƒçmå_StrIntStr int
					var _v__v_ƒçmå_StrIntStr string
					__k__v_ƒçmå_StrIntStr, __k__v_ƒçmå_StrIntStrSize := binary.Varint(in[_n:])
					_k__v_ƒçmå_StrIntStr = int(__k__v_ƒçmå_StrIntStr)
					_n += __k__v_ƒçmå_StrIntStrSize
					__v__v_ƒçmå_StrIntStrLen, __v__v_ƒçmå_StrIntStrLenSize := binary.Varint(in[_n:])
					_n += __v__v_ƒçmå_StrIntStrLenSize
					_v__v_ƒçmå_StrIntStr = string(in[_n : _n+int(__v__v_ƒçmå_StrIntStrLen)])
					_n += int(__v__v_ƒçmå_StrIntStrLen)
					_v_ƒçmå_StrIntStr[_k__v_ƒçmå_StrIntStr] = _v__v_ƒçmå_StrIntStr
				}
			}
			(*m).StrIntStr[_k_ƒçmå_StrIntStr] = _v_ƒçmå_StrIntStr
		}
	}
	// PointerStrInt
	if in[_n] == 0 {
		_n += 1
		(*m).PointerStrInt = nil
	} else {
		_n += 1
		var _p_ƒçmå_PointerStrInt map[string]int
		if in[_n] == 0 {
			_n += 1
			_p_ƒçmå_PointerStrInt = nil
		} else {
			_n += 1
			__p_ƒçmå_PointerStrIntLen, __p_ƒçmå_PointerStrIntLenSize := binary.Varint(in[_n:])
			_n += __p_ƒçmå_PointerStrIntLenSize
			_p_ƒçmå_PointerStrInt = make(map[string]int, __p_ƒçmå_PointerStrIntLen)
			for _i := int64(0); _i < __p_ƒçmå_PointerStrIntLen; _i++ {
				var _k__p_ƒçmå_PointerStrInt string
				var _v__p_ƒçmå_PointerStrInt int
				__k__p_ƒçmå_PointerStrIntLen, __k__p_ƒçmå_PointerStrIntLenSize := binary.Varint(in[_n:])
				_n += __k__p_ƒçmå_PointerStrIntLenSize
				_k__p_ƒçmå_PointerStrInt = string(in[_n : _n+int(__k__p_ƒçmå_PointerStrIntLen)])
				_n += int(__k__p_ƒçmå_PointerStrIntLen)
				__v__p_ƒçmå_PointerStrInt, __v__p_ƒçmå_PointerStrIntSize := binary.Varint(in[_n:])
				_v__p_ƒçmå_PointerStrInt = int(__v__p_ƒçmå_PointerStrInt)
				_n += __v__p_ƒçmå_PointerStrIntSize
				_p_ƒçmå_PointerStrInt[_k__p_ƒçmå_PointerStrInt] = _v__p_ƒçmå_PointerStrInt
			}
		}
		(*m).PointerStrInt = &_p_ƒçmå_PointerStrInt
	}
	// StructStruct
	if in[_n] == 0 {
		_n += 1
		(*m).StructStruct = nil
	} else {
		_n += 1
		_ƒçmå_StructStructLen, _ƒçmå_StructStructLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_StructStructLenSize
		(*m).StructStruct = make(map[TestStructKey]TestStruct, _ƒçmå_StructStructLen)
		for _i := int64(0); _i < _ƒçmå_StructStructLen; _i++ {
			var _k_ƒçmå_StructStruct TestStructKey
			var _v_ƒçmå_StructStruct TestStruct
			// Int
			__k_ƒçmå_StructStruct_Int, __k_ƒçmå_StructStruct_IntSize := binary.Varint(in[_n:])
			_k_ƒçmå_StructStruct.Int = int(__k_ƒçmå_StructStruct_Int)
			_n += __k_ƒçmå_StructStruct_IntSize
			// Str
			__k_ƒçmå_StructStruct_StrLen, __k_ƒçmå_StructStruct_StrLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçmå_StructStruct_StrLenSize
			_k_ƒçmå_StructStruct.Str = string(in[_n : _n+int(__k_ƒçmå_StructStruct_StrLen)])
			_n += int(__k_ƒçmå_StructStruct_StrLen)

			// Int
			__v_ƒçmå_StructStruct_Int, __v_ƒçmå_StructStruct_IntSize := binary.Varint(in[_n:])
			_v_ƒçmå_StructStruct.Int = int(__v_ƒçmå_StructStruct_Int)
			_n += __v_ƒçmå_StructStruct_IntSize
			// Str
			__v_ƒçmå_StructStruct_StrLen, __v_ƒçmå_StructStruct_StrLenSize := binary.Varint(in[_n:])
			_n += __v_ƒçmå_StructStruct_StrLenSize
			_v_ƒçmå_StructStruct.Str = string(in[_n : _n+int(__v_ƒçmå_StructStruct_StrLen)])
			_n += int(__v_ƒçmå_StructStruct_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StructStruct.Pint = nil
			} else {
				_n += 1
				var _p__v_ƒçmå_StructStruct_Pint int
				__p__v_ƒçmå_StructStruct_Pint, __p__v_ƒçmå_StructStruct_PintSize := binary.Varint(in[_n:])
				_p__v_ƒçmå_StructStruct_Pint = int(__p__v_ƒçmå_StructStruct_Pint)
				_n += __p__v_ƒçmå_StructStruct_PintSize
				_v_ƒçmå_StructStruct.Pint = &_p__v_ƒçmå_StructStruct_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StructStruct.Strs = nil
			} else {
				_n += 1
				__v_ƒçmå_StructStruct_StrsLen, __v_ƒçmå_StructStruct_StrsLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçmå_StructStruct_StrsLenSize
				_v_ƒçmå_StructStruct.Strs = make([]string, __v_ƒçmå_StructStruct_StrsLen)
				for _i := int64(0); _i < __v_ƒçmå_StructStruct_StrsLen; _i++ {
					var _e__v_ƒçmå_StructStruct_Strs string
					__e__v_ƒçmå_StructStruct_StrsLen, __e__v_ƒçmå_StructStruct_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__v_ƒçmå_StructStruct_StrsLenSize
					_e__v_ƒçmå_StructStruct_Strs = string(in[_n : _n+int(__e__v_ƒçmå_StructStruct_StrsLen)])
					_n += int(__e__v_ƒçmå_StructStruct_StrsLen)
					_v_ƒçmå_StructStruct.Strs[_i] = _e__v_ƒçmå_StructStruct_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StructStruct.StrInt = nil
			} else {
				_n += 1
				__v_ƒçmå_StructStruct_StrIntLen, __v_ƒçmå_StructStruct_StrIntLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçmå_StructStruct_StrIntLenSize
				_v_ƒçmå_StructStruct.StrInt = make(map[string]int, __v_ƒçmå_StructStruct_StrIntLen)
				for _i := int64(0); _i < __v_ƒçmå_StructStruct_StrIntLen; _i++ {
					var _k__v_ƒçmå_StructStruct_StrInt string
					var _v__v_ƒçmå_StructStruct_StrInt int
					__k__v_ƒçmå_StructStruct_StrIntLen, __k__v_ƒçmå_StructStruct_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__v_ƒçmå_StructStruct_StrIntLenSize
					_k__v_ƒçmå_StructStruct_StrInt = string(in[_n : _n+int(__k__v_ƒçmå_StructStruct_StrIntLen)])
					_n += int(__k__v_ƒçmå_StructStruct_StrIntLen)
					__v__v_ƒçmå_StructStruct_StrInt, __v__v_ƒçmå_StructStruct_StrIntSize := binary.Varint(in[_n:])
					_v__v_ƒçmå_StructStruct_StrInt = int(__v__v_ƒçmå_StructStruct_StrInt)
					_n += __v__v_ƒçmå_StructStruct_StrIntSize
					_v_ƒçmå_StructStruct.StrInt[_k__v_ƒçmå_StructStruct_StrInt] = _v__v_ƒçmå_StructStruct_StrInt
				}
			}

			(*m).StructStruct[_k_ƒçmå_StructStruct] = _v_ƒçmå_StructStruct
		}
	}
	// StructPstruct
	if in[_n] == 0 {
		_n += 1
		(*m).StructPstruct = nil
	} else {
		_n += 1
		_ƒçmå_StructPstructLen, _ƒçmå_StructPstructLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_StructPstructLenSize
		(*m).StructPstruct = make(map[TestStructKey]*TestStruct, _ƒçmå_StructPstructLen)
		for _i := int64(0); _i < _ƒçmå_StructPstructLen; _i++ {
			var _k_ƒçmå_StructPstruct TestStructKey
			var _v_ƒçmå_StructPstruct *TestStruct
			// Int
			__k_ƒçmå_StructPstruct_Int, __k_ƒçmå_StructPstruct_IntSize := binary.Varint(in[_n:])
			_k_ƒçmå_StructPstruct.Int = int(__k_ƒçmå_StructPstruct_Int)
			_n += __k_ƒçmå_StructPstruct_IntSize
			// Str
			__k_ƒçmå_StructPstruct_StrLen, __k_ƒçmå_StructPstruct_StrLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçmå_StructPstruct_StrLenSize
			_k_ƒçmå_StructPstruct.Str = string(in[_n : _n+int(__k_ƒçmå_StructPstruct_StrLen)])
			_n += int(__k_ƒçmå_StructPstruct_StrLen)

			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StructPstruct = nil
			} else {
				_n += 1
				var _p__v_ƒçmå_StructPstruct TestStruct
				// Int
				__p__v_ƒçmå_StructPstruct_Int, __p__v_ƒçmå_StructPstruct_IntSize := binary.Varint(in[_n:])
				_p__v_ƒçmå_StructPstruct.Int = int(__p__v_ƒçmå_StructPstruct_Int)
				_n += __p__v_ƒçmå_StructPstruct_IntSize
				// Str
				__p__v_ƒçmå_StructPstruct_StrLen, __p__v_ƒçmå_StructPstruct_StrLenSize := binary.Varint(in[_n:])
				_n += __p__v_ƒçmå_StructPstruct_StrLenSize
				_p__v_ƒçmå_StructPstruct.Str = string(in[_n : _n+int(__p__v_ƒçmå_StructPstruct_StrLen)])
				_n += int(__p__v_ƒçmå_StructPstruct_StrLen)
				// Pint
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçmå_StructPstruct.Pint = nil
				} else {
					_n += 1
					var _p__p__v_ƒçmå_StructPstruct_Pint int
					__p__p__v_ƒçmå_StructPstruct_Pint, __p__p__v_ƒçmå_StructPstruct_PintSize := binary.Varint(in[_n:])
					_p__p__v_ƒçmå_StructPstruct_Pint = int(__p__p__v_ƒçmå_StructPstruct_Pint)
					_n += __p__p__v_ƒçmå_StructPstruct_PintSize
					_p__v_ƒçmå_StructPstruct.Pint = &_p__p__v_ƒçmå_StructPstruct_Pint
				}
				// Strs
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçmå_StructPstruct.Strs = nil
				} else {
					_n += 1
					__p__v_ƒçmå_StructPstruct_StrsLen, __p__v_ƒçmå_StructPstruct_StrsLenSize := binary.Varint(in[_n:])
					_n += __p__v_ƒçmå_StructPstruct_StrsLenSize
					_p__v_ƒçmå_StructPstruct.Strs = make([]string, __p__v_ƒçmå_StructPstruct_StrsLen)
					for _i := int64(0); _i < __p__v_ƒçmå_StructPstruct_StrsLen; _i++ {
						var _e__p__v_ƒçmå_StructPstruct_Strs string
						__e__p__v_ƒçmå_StructPstruct_StrsLen, __e__p__v_ƒçmå_StructPstruct_StrsLenSize := binary.Varint(in[_n:])
						_n += __e__p__v_ƒçmå_StructPstruct_StrsLenSize
						_e__p__v_ƒçmå_StructPstruct_Strs = string(in[_n : _n+int(__e__p__v_ƒçmå_StructPstruct_StrsLen)])
						_n += int(__e__p__v_ƒçmå_StructPstruct_StrsLen)
						_p__v_ƒçmå_StructPstruct.Strs[_i] = _e__p__v_ƒçmå_StructPstruct_Strs
					}
				}
				// StrInt
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçmå_StructPstruct.StrInt = nil
				} else {
					_n += 1
					__p__v_ƒçmå_StructPstruct_StrIntLen, __p__v_ƒçmå_StructPstruct_StrIntLenSize := binary.Varint(in[_n:])
					_n += __p__v_ƒçmå_StructPstruct_StrIntLenSize
					_p__v_ƒçmå_StructPstruct.StrInt = make(map[string]int, __p__v_ƒçmå_StructPstruct_StrIntLen)
					for _i := int64(0); _i < __p__v_ƒçmå_StructPstruct_StrIntLen; _i++ {
						var _k__p__v_ƒçmå_StructPstruct_StrInt string
						var _v__p__v_ƒçmå_StructPstruct_StrInt int
						__k__p__v_ƒçmå_StructPstruct_StrIntLen, __k__p__v_ƒçmå_StructPstruct_StrIntLenSize := binary.Varint(in[_n:])
						_n += __k__p__v_ƒçmå_StructPstruct_StrIntLenSize
						_k__p__v_ƒçmå_StructPstruct_StrInt = string(in[_n : _n+int(__k__p__v_ƒçmå_StructPstruct_StrIntLen)])
						_n += int(__k__p__v_ƒçmå_StructPstruct_StrIntLen)
						__v__p__v_ƒçmå_StructPstruct_StrInt, __v__p__v_ƒçmå_StructPstruct_StrIntSize := binary.Varint(in[_n:])
						_v__p__v_ƒçmå_StructPstruct_StrInt = int(__v__p__v_ƒçmå_StructPstruct_StrInt)
						_n += __v__p__v_ƒçmå_StructPstruct_StrIntSize
						_p__v_ƒçmå_StructPstruct.StrInt[_k__p__v_ƒçmå_StructPstruct_StrInt] = _v__p__v_ƒçmå_StructPstruct_StrInt
					}
				}

				_v_ƒçmå_StructPstruct = &_p__v_ƒçmå_StructPstruct
			}
			(*m).StructPstruct[_k_ƒçmå_StructPstruct] = _v_ƒçmå_StructPstruct
		}
	}

	return _n, nil
}

func (s *Slice) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *Slice) Decode(in []byte) (*Slice, error) {
	_, err := DecodeSlice(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *Slice) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		// Strs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Strs {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
		// Intss
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Intss {
			_ = _e
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _e {
				_ = _e
				_size += binary.MaxVarintLen64
			}
		}
		// Pints
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Pints {
			_ = _e
			_size += 1 // is nil
			if _e != nil {
				_size += binary.MaxVarintLen64
			}
		}
		// PointerStrs
		_size += 1 // is nil
		if (*s).PointerStrs != nil {
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range *(*s).PointerStrs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
		}
		// Structs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Structs {
			_ = _e
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_e.Str)
			// Pint
			_size += 1 // is nil
			if _e.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _e.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _e.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
		// Pstructs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*s).Pstructs {
			_ = _e
			_size += 1 // is nil
			if _e != nil {
				// Int
				_size += binary.MaxVarintLen64
				// Str
				_size += binary.MaxVarintLen64 + len((*_e).Str)
				// Pint
				_size += 1 // is nil
				if (*_e).Pint != nil {
					_size += binary.MaxVarintLen64
				}
				// Strs
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _, _e := range (*_e).Strs {
					_ = _e
					_size += binary.MaxVarintLen64 + len(_e)
				}
				// StrInt
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _k, _v := range (*_e).StrInt {
					_, _ = _k, _v
					_size += binary.MaxVarintLen64 + len(_k)
					_size += binary.MaxVarintLen64
				}
			}
		}
		// Auint8
		for _, _e := range (*s).Auint8 {
			_ = _e
			_size += 1
		}
		// Apstr
		for _, _e := range (*s).Apstr {
			_ = _e
			_size += 1 // is nil
			if _e != nil {
				_size += binary.MaxVarintLen64 + len((*_e))
			}
		}
	}
	return _size
}

func (s *Slice) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Strs
		if (*s).Strs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Strs)))
			for _, _e := range (*s).Strs {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
		// Intss
		if (*s).Intss == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Intss)))
			for _, _e := range (*s).Intss {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e)))
					for _, _e := range _e {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(_e))
					}
				}
			}
		}
		// Pints
		if (*s).Pints == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Pints)))
			for _, _e := range (*s).Pints {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_e)))
				}
			}
		}
		// PointerStrs
		if (*s).PointerStrs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			if (*(*s).PointerStrs) == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64(len((*(*s).PointerStrs))))
				for _, _e := range *(*s).PointerStrs {
					_ = _e
					_n += binary.PutVarint(out[_n:], int64(len(_e)))
					_n += copy(out[_n:], _e)
				}
			}
		}
		// Structs
		if (*s).Structs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Structs)))
			for _, _e := range (*s).Structs {
				_ = _e
				// Int
				_n += binary.PutVarint(out[_n:], int64(_e.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_e.Str)))
				_n += copy(out[_n:], _e.Str)
				// Pint
				if _e.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_e.Pint)))
				}
				// Strs
				if _e.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.Strs)))
					for _, _e := range _e.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _e.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.StrInt)))
					for _k, _v := range _e.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}
		// Pstructs
		if (*s).Pstructs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s).Pstructs)))
			for _, _e := range (*s).Pstructs {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					// Int
					_n += binary.PutVarint(out[_n:], int64((*_e).Int))
					// Str
					_n += binary.PutVarint(out[_n:], int64(len((*_e).Str)))
					_n += copy(out[_n:], (*_e).Str)
					// Pint
					if (*_e).Pint == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64((*(*_e).Pint)))
					}
					// Strs
					if (*_e).Strs == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_e).Strs)))
						for _, _e := range (*_e).Strs {
							_ = _e
							_n += binary.PutVarint(out[_n:], int64(len(_e)))
							_n += copy(out[_n:], _e)
						}
					}
					// StrInt
					if (*_e).StrInt == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_e).StrInt)))
						for _k, _v := range (*_e).StrInt {
							_, _ = _k, _v
							_n += binary.PutVarint(out[_n:], int64(len(_k)))
							_n += copy(out[_n:], _k)
							_n += binary.PutVarint(out[_n:], int64(_v))
						}
					}

				}
			}
		}
		// Auint8
		for _, _e := range (*s).Auint8 {
			out[_n] = byte(_e)
			_n += 1
		}
		// Apstr
		for _, _e := range (*s).Apstr {
			if _e == nil {
				out[_n] = 0
				_n += 1
			} else {
				out[_n] = 1
				_n += 1
				_n += binary.PutVarint(out[_n:], int64(len((*_e))))
				_n += copy(out[_n:], (*_e))
			}
		}

	}

	return _n, nil
}

func DecodeSlice(in []byte, s *Slice) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Strs
	if in[_n] == 0 {
		_n += 1
		(*s).Strs = nil
	} else {
		_n += 1
		_ƒçså_StrsLen, _ƒçså_StrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_StrsLenSize
		(*s).Strs = make([]string, _ƒçså_StrsLen)
		for _i := int64(0); _i < _ƒçså_StrsLen; _i++ {
			var _e_ƒçså_Strs string
			__e_ƒçså_StrsLen, __e_ƒçså_StrsLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçså_StrsLenSize
			_e_ƒçså_Strs = string(in[_n : _n+int(__e_ƒçså_StrsLen)])
			_n += int(__e_ƒçså_StrsLen)
			(*s).Strs[_i] = _e_ƒçså_Strs
		}
	}
	// Intss
	if in[_n] == 0 {
		_n += 1
		(*s).Intss = nil
	} else {
		_n += 1
		_ƒçså_IntssLen, _ƒçså_IntssLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_IntssLenSize
		(*s).Intss = make([][]int, _ƒçså_IntssLen)
		for _i := int64(0); _i < _ƒçså_IntssLen; _i++ {
			var _e_ƒçså_Intss []int
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Intss = nil
			} else {
				_n += 1
				__e_ƒçså_IntssLen, __e_ƒçså_IntssLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçså_IntssLenSize
				_e_ƒçså_Intss = make([]int, __e_ƒçså_IntssLen)
				for _i := int64(0); _i < __e_ƒçså_IntssLen; _i++ {
					var _e__e_ƒçså_Intss int
					__e__e_ƒçså_Intss, __e__e_ƒçså_IntssSize := binary.Varint(in[_n:])
					_e__e_ƒçså_Intss = int(__e__e_ƒçså_Intss)
					_n += __e__e_ƒçså_IntssSize
					_e_ƒçså_Intss[_i] = _e__e_ƒçså_Intss
				}
			}
			(*s).Intss[_i] = _e_ƒçså_Intss
		}
	}
	// Pints
	if in[_n] == 0 {
		_n += 1
		(*s).Pints = nil
	} else {
		_n += 1
		_ƒçså_PintsLen, _ƒçså_PintsLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_PintsLenSize
		(*s).Pints = make([]*int, _ƒçså_PintsLen)
		for _i := int64(0); _i < _ƒçså_PintsLen; _i++ {
			var _e_ƒçså_Pints *int
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Pints = nil
			} else {
				_n += 1
				var _p__e_ƒçså_Pints int
				__p__e_ƒçså_Pints, __p__e_ƒçså_PintsSize := binary.Varint(in[_n:])
				_p__e_ƒçså_Pints = int(__p__e_ƒçså_Pints)
				_n += __p__e_ƒçså_PintsSize
				_e_ƒçså_Pints = &_p__e_ƒçså_Pints
			}
			(*s).Pints[_i] = _e_ƒçså_Pints
		}
	}
	// PointerStrs
	if in[_n] == 0 {
		_n += 1
		(*s).PointerStrs = nil
	} else {
		_n += 1
		var _p_ƒçså_PointerStrs []string
		if in[_n] == 0 {
			_n += 1
			_p_ƒçså_PointerStrs = nil
		} else {
			_n += 1
			__p_ƒçså_PointerStrsLen, __p_ƒçså_PointerStrsLenSize := binary.Varint(in[_n:])
			_n += __p_ƒçså_PointerStrsLenSize
			_p_ƒçså_PointerStrs = make([]string, __p_ƒçså_PointerStrsLen)
			for _i := int64(0); _i < __p_ƒçså_PointerStrsLen; _i++ {
				var _e__p_ƒçså_PointerStrs string
				__e__p_ƒçså_PointerStrsLen, __e__p_ƒçså_PointerStrsLenSize := binary.Varint(in[_n:])
				_n += __e__p_ƒçså_PointerStrsLenSize
				_e__p_ƒçså_PointerStrs = string(in[_n : _n+int(__e__p_ƒçså_PointerStrsLen)])
				_n += int(__e__p_ƒçså_PointerStrsLen)
				_p_ƒçså_PointerStrs[_i] = _e__p_ƒçså_PointerStrs
			}
		}
		(*s).PointerStrs = &_p_ƒçså_PointerStrs
	}
	// Structs
	if in[_n] == 0 {
		_n += 1
		(*s).Structs = nil
	} else {
		_n += 1
		_ƒçså_StructsLen, _ƒçså_StructsLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_StructsLenSize
		(*s).Structs = make([]TestStruct, _ƒçså_StructsLen)
		for _i := int64(0); _i < _ƒçså_StructsLen; _i++ {
			var _e_ƒçså_Structs TestStruct
			// Int
			__e_ƒçså_Structs_Int, __e_ƒçså_Structs_IntSize := binary.Varint(in[_n:])
			_e_ƒçså_Structs.Int = int(__e_ƒçså_Structs_Int)
			_n += __e_ƒçså_Structs_IntSize
			// Str
			__e_ƒçså_Structs_StrLen, __e_ƒçså_Structs_StrLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçså_Structs_StrLenSize
			_e_ƒçså_Structs.Str = string(in[_n : _n+int(__e_ƒçså_Structs_StrLen)])
			_n += int(__e_ƒçså_Structs_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Structs.Pint = nil
			} else {
				_n += 1
				var _p__e_ƒçså_Structs_Pint int
				__p__e_ƒçså_Structs_Pint, __p__e_ƒçså_Structs_PintSize := binary.Varint(in[_n:])
				_p__e_ƒçså_Structs_Pint = int(__p__e_ƒçså_Structs_Pint)
				_n += __p__e_ƒçså_Structs_PintSize
				_e_ƒçså_Structs.Pint = &_p__e_ƒçså_Structs_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Structs.Strs = nil
			} else {
				_n += 1
				__e_ƒçså_Structs_StrsLen, __e_ƒçså_Structs_StrsLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçså_Structs_StrsLenSize
				_e_ƒçså_Structs.Strs = make([]string, __e_ƒçså_Structs_StrsLen)
				for _i := int64(0); _i < __e_ƒçså_Structs_StrsLen; _i++ {
					var _e__e_ƒçså_Structs_Strs string
					__e__e_ƒçså_Structs_StrsLen, __e__e_ƒçså_Structs_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__e_ƒçså_Structs_StrsLenSize
					_e__e_ƒçså_Structs_Strs = string(in[_n : _n+int(__e__e_ƒçså_Structs_StrsLen)])
					_n += int(__e__e_ƒçså_Structs_StrsLen)
					_e_ƒçså_Structs.Strs[_i] = _e__e_ƒçså_Structs_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Structs.StrInt = nil
			} else {
				_n += 1
				__e_ƒçså_Structs_StrIntLen, __e_ƒçså_Structs_StrIntLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçså_Structs_StrIntLenSize
				_e_ƒçså_Structs.StrInt = make(map[string]int, __e_ƒçså_Structs_StrIntLen)
				for _i := int64(0); _i < __e_ƒçså_Structs_StrIntLen; _i++ {
					var _k__e_ƒçså_Structs_StrInt string
					var _v__e_ƒçså_Structs_StrInt int
					__k__e_ƒçså_Structs_StrIntLen, __k__e_ƒçså_Structs_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__e_ƒçså_Structs_StrIntLenSize
					_k__e_ƒçså_Structs_StrInt = string(in[_n : _n+int(__k__e_ƒçså_Structs_StrIntLen)])
					_n += int(__k__e_ƒçså_Structs_StrIntLen)
					__v__e_ƒçså_Structs_StrInt, __v__e_ƒçså_Structs_StrIntSize := binary.Varint(in[_n:])
					_v__e_ƒçså_Structs_StrInt = int(__v__e_ƒçså_Structs_StrInt)
					_n += __v__e_ƒçså_Structs_StrIntSize
					_e_ƒçså_Structs.StrInt[_k__e_ƒçså_Structs_StrInt] = _v__e_ƒçså_Structs_StrInt
				}
			}

			(*s).Structs[_i] = _e_ƒçså_Structs
		}
	}
	// Pstructs
	if in[_n] == 0 {
		_n += 1
		(*s).Pstructs = nil
	} else {
		_n += 1
		_ƒçså_PstructsLen, _ƒçså_PstructsLenSize := binary.Varint(in[_n:])
		_n += _ƒçså_PstructsLenSize
		(*s).Pstructs = make([]*TestStruct, _ƒçså_PstructsLen)
		for _i := int64(0); _i < _ƒçså_PstructsLen; _i++ {
			var _e_ƒçså_Pstructs *TestStruct
			if in[_n] == 0 {
				_n += 1
				_e_ƒçså_Pstructs = nil
			} else {
				_n += 1
				var _p__e_ƒçså_Pstructs TestStruct
				// Int
				__p__e_ƒçså_Pstructs_Int, __p__e_ƒçså_Pstructs_IntSize := binary.Varint(in[_n:])
				_p__e_ƒçså_Pstructs.Int = int(__p__e_ƒçså_Pstructs_Int)
				_n += __p__e_ƒçså_Pstructs_IntSize
				// Str
				__p__e_ƒçså_Pstructs_StrLen, __p__e_ƒçså_Pstructs_StrLenSize := binary.Varint(in[_n:])
				_n += __p__e_ƒçså_Pstructs_StrLenSize
				_p__e_ƒçså_Pstructs.Str = string(in[_n : _n+int(__p__e_ƒçså_Pstructs_StrLen)])
				_n += int(__p__e_ƒçså_Pstructs_StrLen)
				// Pint
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçså_Pstructs.Pint = nil
				} else {
					_n += 1
					var _p__p__e_ƒçså_Pstructs_Pint int
					__p__p__e_ƒçså_Pstructs_Pint, __p__p__e_ƒçså_Pstructs_PintSize := binary.Varint(in[_n:])
					_p__p__e_ƒçså_Pstructs_Pint = int(__p__p__e_ƒçså_Pstructs_Pint)
					_n += __p__p__e_ƒçså_Pstructs_PintSize
					_p__e_ƒçså_Pstructs.Pint = &_p__p__e_ƒçså_Pstructs_Pint
				}
				// Strs
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçså_Pstructs.Strs = nil
				} else {
					_n += 1
					__p__e_ƒçså_Pstructs_StrsLen, __p__e_ƒçså_Pstructs_StrsLenSize := binary.Varint(in[_n:])
					_n += __p__e_ƒçså_Pstructs_StrsLenSize
					_p__e_ƒçså_Pstructs.Strs = make([]string, __p__e_ƒçså_Pstructs_StrsLen)
					for _i := int64(0); _i < __p__e_ƒçså_Pstructs_StrsLen; _i++ {
						var _e__p__e_ƒçså_Pstructs_Strs string
						__e__p__e_ƒçså_Pstructs_StrsLen, __e__p__e_ƒçså_Pstructs_StrsLenSize := binary.Varint(in[_n:])
						_n += __e__p__e_ƒçså_Pstructs_StrsLenSize
						_e__p__e_ƒçså_Pstructs_Strs = string(in[_n : _n+int(__e__p__e_ƒçså_Pstructs_StrsLen)])
						_n += int(__e__p__e_ƒçså_Pstructs_StrsLen)
						_p__e_ƒçså_Pstructs.Strs[_i] = _e__p__e_ƒçså_Pstructs_Strs
					}
				}
				// StrInt
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçså_Pstructs.StrInt = nil
				} else {
					_n += 1
					__p__e_ƒçså_Pstructs_StrIntLen, __p__e_ƒçså_Pstructs_StrIntLenSize := binary.Varint(in[_n:])
					_n += __p__e_ƒçså_Pstructs_StrIntLenSize
					_p__e_ƒçså_Pstructs.StrInt = make(map[string]int, __p__e_ƒçså_Pstructs_StrIntLen)
					for _i := int64(0); _i < __p__e_ƒçså_Pstructs_StrIntLen; _i++ {
						var _k__p__e_ƒçså_Pstructs_StrInt string
						var _v__p__e_ƒçså_Pstructs_StrInt int
						__k__p__e_ƒçså_Pstructs_StrIntLen, __k__p__e_ƒçså_Pstructs_StrIntLenSize := binary.Varint(in[_n:])
						_n += __k__p__e_ƒçså_Pstructs_StrIntLenSize
						_k__p__e_ƒçså_Pstructs_StrInt = string(in[_n : _n+int(__k__p__e_ƒçså_Pstructs_StrIntLen)])
						_n += int(__k__p__e_ƒçså_Pstructs_StrIntLen)
						__v__p__e_ƒçså_Pstructs_StrInt, __v__p__e_ƒçså_Pstructs_StrIntSize := binary.Varint(in[_n:])
						_v__p__e_ƒçså_Pstructs_StrInt = int(__v__p__e_ƒçså_Pstructs_StrInt)
						_n += __v__p__e_ƒçså_Pstructs_StrIntSize
						_p__e_ƒçså_Pstructs.StrInt[_k__p__e_ƒçså_Pstructs_StrInt] = _v__p__e_ƒçså_Pstructs_StrInt
					}
				}

				_e_ƒçså_Pstructs = &_p__e_ƒçså_Pstructs
			}
			(*s).Pstructs[_i] = _e_ƒçså_Pstructs
		}
	}
	// Auint8
	for _i := 0; _i < 5; _i++ {
		var _e_ƒçså_Auint8 uint8
		_e_ƒçså_Auint8 = uint8(in[_n])
		_n += 1
		(*s).Auint8[_i] = _e_ƒçså_Auint8
	}
	// Apstr
	for _i := 0; _i < 5; _i++ {
		var _e_ƒçså_Apstr *string
		if in[_n] == 0 {
			_n += 1
			_e_ƒçså_Apstr = nil
		} else {
			_n += 1
			var _p__e_ƒçså_Apstr string
			__p__e_ƒçså_ApstrLen, __p__e_ƒçså_ApstrLenSize := binary.Varint(in[_n:])
			_n += __p__e_ƒçså_ApstrLenSize
			_p__e_ƒçså_Apstr = string(in[_n : _n+int(__p__e_ƒçså_ApstrLen)])
			_n += int(__p__e_ƒçså_ApstrLen)
			_e_ƒçså_Apstr = &_p__e_ƒçså_Apstr
		}
		(*s).Apstr[_i] = _e_ƒçså_Apstr
	}

	return _n, nil
}

func (m *MapSlice) Encode() ([]byte, error) {
	out := make([]byte, m.MaxSize())

	_n, err := m.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (m *MapSlice) Decode(in []byte) (*MapSlice, error) {
	_, err := DecodeMapSlice(in, m)
	if err != nil {
		return m, err
	}

	return m, nil
}

func (m *MapSlice) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if m != nil {
		// StrInts
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*m).StrInts {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _v {
				_ = _e
				_size += binary.MaxVarintLen64
			}
		}
		// IntStrs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*m).IntStrs {
			_ = _e
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _e {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64
				_size += binary.MaxVarintLen64 + len(_v)
			}
		}
	}
	return _size
}

func (m *MapSlice) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if m == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// StrInts
		if (*m).StrInts == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).StrInts)))
			for _k, _v := range (*m).StrInts {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				if _v == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v)))
					for _, _e := range _v {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(_e))
					}
				}
			}
		}
		// IntStrs
		if (*m).IntStrs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*m).IntStrs)))
			for _, _e := range (*m).IntStrs {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e)))
					for _k, _v := range _e {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(_k))
						_n += binary.PutVarint(out[_n:], int64(len(_v)))
						_n += copy(out[_n:], _v)
					}
				}
			}
		}

	}

	return _n, nil
}

func DecodeMapSlice(in []byte, m *MapSlice) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// StrInts
	if in[_n] == 0 {
		_n += 1
		(*m).StrInts = nil
	} else {
		_n += 1
		_ƒçmå_StrIntsLen, _ƒçmå_StrIntsLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_StrIntsLenSize
		(*m).StrInts = make(map[string][]int, _ƒçmå_StrIntsLen)
		for _i := int64(0); _i < _ƒçmå_StrIntsLen; _i++ {
			var _k_ƒçmå_StrInts string
			var _v_ƒçmå_StrInts []int
			__k_ƒçmå_StrIntsLen, __k_ƒçmå_StrIntsLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçmå_StrIntsLenSize
			_k_ƒçmå_StrInts = string(in[_n : _n+int(__k_ƒçmå_StrIntsLen)])
			_n += int(__k_ƒçmå_StrIntsLen)
			if in[_n] == 0 {
				_n += 1
				_v_ƒçmå_StrInts = nil
			} else {
				_n += 1
				__v_ƒçmå_StrIntsLen, __v_ƒçmå_StrIntsLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçmå_StrIntsLenSize
				_v_ƒçmå_StrInts = make([]int, __v_ƒçmå_StrIntsLen)
				for _i := int64(0); _i < __v_ƒçmå_StrIntsLen; _i++ {
					var _e__v_ƒçmå_StrInts int
					__e__v_ƒçmå_StrInts, __e__v_ƒçmå_StrIntsSize := binary.Varint(in[_n:])
					_e__v_ƒçmå_StrInts = int(__e__v_ƒçmå_StrInts)
					_n += __e__v_ƒçmå_StrIntsSize
					_v_ƒçmå_StrInts[_i] = _e__v_ƒçmå_StrInts
				}
			}
			(*m).StrInts[_k_ƒçmå_StrInts] = _v_ƒçmå_StrInts
		}
	}
	// IntStrs
	if in[_n] == 0 {
		_n += 1
		(*m).IntStrs = nil
	} else {
		_n += 1
		_ƒçmå_IntStrsLen, _ƒçmå_IntStrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçmå_IntStrsLenSize
		(*m).IntStrs = make([]map[int]string, _ƒçmå_IntStrsLen)
		for _i := int64(0); _i < _ƒçmå_IntStrsLen; _i++ {
			var _e_ƒçmå_IntStrs map[int]string
			if in[_n] == 0 {
				_n += 1
				_e_ƒçmå_IntStrs = nil
			} else {
				_n += 1
				__e_ƒçmå_IntStrsLen, __e_ƒçmå_IntStrsLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçmå_IntStrsLenSize
				_e_ƒçmå_IntStrs = make(map[int]string, __e_ƒçmå_IntStrsLen)
				for _i := int64(0); _i < __e_ƒçmå_IntStrsLen; _i++ {
					var _k__e_ƒçmå_IntStrs int
					var _v__e_ƒçmå_IntStrs string
					__k__e_ƒçmå_IntStrs, __k__e_ƒçmå_IntStrsSize := binary.Varint(in[_n:])
					_k__e_ƒçmå_IntStrs = int(__k__e_ƒçmå_IntStrs)
					_n += __k__e_ƒçmå_IntStrsSize
					__v__e_ƒçmå_IntStrsLen, __v__e_ƒçmå_IntStrsLenSize := binary.Varint(in[_n:])
					_n += __v__e_ƒçmå_IntStrsLenSize
					_v__e_ƒçmå_IntStrs = string(in[_n : _n+int(__v__e_ƒçmå_IntStrsLen)])
					_n += int(__v__e_ƒçmå_IntStrsLen)
					_e_ƒçmå_IntStrs[_k__e_ƒçmå_IntStrs] = _v__e_ƒçmå_IntStrs
				}
			}
			(*m).IntStrs[_i] = _e_ƒçmå_IntStrs
		}
	}

	return _n, nil
}

func (p *PointerMap) Encode() ([]byte, error) {
	out := make([]byte, p.MaxSize())

	_n, err := p.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (p *PointerMap) Decode(in []byte) (*PointerMap, error) {
	_, err := DecodePointerMap(in, p)
	if err != nil {
		return p, err
	}

	return p, nil
}

func (p *PointerMap) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if p != nil {
		// PstrPint
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*p).PstrPint {
			_, _ = _k, _v
			_size += 1 // is nil
			if _k != nil {
				_size += binary.MaxVarintLen64 + len((*_k))
			}
			_size += 1 // is nil
			if _v != nil {
				_size += binary.MaxVarintLen64
			}
		}
	}
	return _size
}

func (p *PointerMap) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if p == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// PstrPint
		if (*p).PstrPint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*p).PstrPint)))
			for _k, _v := range (*p).PstrPint {
				_, _ = _k, _v
				if _k == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len((*_k))))
					_n += copy(out[_n:], (*_k))
				}
				if _v == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_v)))
				}
			}
		}

	}

	return _n, nil
}

func DecodePointerMap(in []byte, p *PointerMap) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// PstrPint
	if in[_n] == 0 {
		_n += 1
		(*p).PstrPint = nil
	} else {
		_n += 1
		_ƒçpå_PstrPintLen, _ƒçpå_PstrPintLenSize := binary.Varint(in[_n:])
		_n += _ƒçpå_PstrPintLenSize
		(*p).PstrPint = make(map[*string]*int, _ƒçpå_PstrPintLen)
		for _i := int64(0); _i < _ƒçpå_PstrPintLen; _i++ {
			var _k_ƒçpå_PstrPint *string
			var _v_ƒçpå_PstrPint *int
			if in[_n] == 0 {
				_n += 1
				_k_ƒçpå_PstrPint = nil
			} else {
				_n += 1
				var _p__k_ƒçpå_PstrPint string
				__p__k_ƒçpå_PstrPintLen, __p__k_ƒçpå_PstrPintLenSize := binary.Varint(in[_n:])
				_n += __p__k_ƒçpå_PstrPintLenSize
				_p__k_ƒçpå_PstrPint = string(in[_n : _n+int(__p__k_ƒçpå_PstrPintLen)])
				_n += int(__p__k_ƒçpå_PstrPintLen)
				_k_ƒçpå_PstrPint = &_p__k_ƒçpå_PstrPint
			}
			if in[_n] == 0 {
				_n += 1
				_v_ƒçpå_PstrPint = nil
			} else {
				_n += 1
				var _p__v_ƒçpå_PstrPint int
				__p__v_ƒçpå_PstrPint, __p__v_ƒçpå_PstrPintSize := binary.Varint(in[_n:])
				_p__v_ƒçpå_PstrPint = int(__p__v_ƒçpå_PstrPint)
				_n += __p__v_ƒçpå_PstrPintSize
				_v_ƒçpå_PstrPint = &_p__v_ƒçpå_PstrPint
			}
			(*p).PstrPint[_k_ƒçpå_PstrPint] = _v_ƒçpå_PstrPint
		}
	}

	return _n, nil
}

func (f *FixedLengths) Encode() ([]byte, error) {
	out := make([]byte, f.MaxSize())

	_n, err := f.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (f *FixedLengths) Decode(in []byte) (*FixedLengths, error) {
	_, err := DecodeFixedLengths(in, f)
	if err != nil {
		return f, err
	}

	return f, nil
}

func (f *FixedLengths) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if f != nil {
		// Map
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*f).Map {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64
			_size += binary.MaxVarintLen64
		}
		// Array
		for _, _e := range (*f).Array {
			_ = _e
			_size += 1
		}
		// Slice
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*f).Slice {
			_ = _e
			_size += binary.MaxVarintLen64
		}
	}
	return _size
}

func (f *FixedLengths) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if f == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Map
		if (*f).Map == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*f).Map)))
			for _k, _v := range (*f).Map {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(_k))
				_n += binary.PutUvarint(out[_n:], uint64(_v))
			}
		}
		// Array
		for _, _e := range (*f).Array {
			out[_n] = byte(_e)
			_n += 1
		}
		// Slice
		if (*f).Slice == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*f).Slice)))
			for _, _e := range (*f).Slice {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(_e))
			}
		}

	}

	return _n, nil
}

func DecodeFixedLengths(in []byte, f *FixedLengths) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Map
	if in[_n] == 0 {
		_n += 1
		(*f).Map = nil
	} else {
		_n += 1
		_ƒçfå_MapLen, _ƒçfå_MapLenSize := binary.Varint(in[_n:])
		_n += _ƒçfå_MapLenSize
		(*f).Map = make(map[int]uint, _ƒçfå_MapLen)
		for _i := int64(0); _i < _ƒçfå_MapLen; _i++ {
			var _k_ƒçfå_Map int
			var _v_ƒçfå_Map uint
			__k_ƒçfå_Map, __k_ƒçfå_MapSize := binary.Varint(in[_n:])
			_k_ƒçfå_Map = int(__k_ƒçfå_Map)
			_n += __k_ƒçfå_MapSize
			__v_ƒçfå_Map, __v_ƒçfå_MapSize := binary.Uvarint(in[_n:])
			_v_ƒçfå_Map = uint(__v_ƒçfå_Map)
			_n += __v_ƒçfå_MapSize
			(*f).Map[_k_ƒçfå_Map] = _v_ƒçfå_Map
		}
	}
	// Array
	for _i := 0; _i < 5; _i++ {
		var _e_ƒçfå_Array uint8
		_e_ƒçfå_Array = uint8(in[_n])
		_n += 1
		(*f).Array[_i] = _e_ƒçfå_Array
	}
	// Slice
	if in[_n] == 0 {
		_n += 1
		(*f).Slice = nil
	} else {
		_n += 1
		_ƒçfå_SliceLen, _ƒçfå_SliceLenSize := binary.Varint(in[_n:])
		_n += _ƒçfå_SliceLenSize
		(*f).Slice = make([]int, _ƒçfå_SliceLen)
		for _i := int64(0); _i < _ƒçfå_SliceLen; _i++ {
			var _e_ƒçfå_Slice int
			__e_ƒçfå_Slice, __e_ƒçfå_SliceSize := binary.Varint(in[_n:])
			_e_ƒçfå_Slice = int(__e_ƒçfå_Slice)
			_n += __e_ƒçfå_SliceSize
			(*f).Slice[_i] = _e_ƒçfå_Slice
		}
	}

	return _n, nil
}

func (u *Unnamed) Encode() ([]byte, error) {
	out := make([]byte, u.MaxSize())

	_n, err := u.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (u *Unnamed) Decode(in []byte) (*Unnamed, error) {
	_, err := DecodeUnnamed(in, u)
	if err != nil {
		return u, err
	}

	return u, nil
}

func (u *Unnamed) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if u != nil {
		// int
		_size += binary.MaxVarintLen64
		// uint
		_size += 1 // is nil
		if (*u).uint != nil {
			_size += binary.MaxVarintLen64
		}
		// TestStruct
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*u).TestStruct.Str)
		// Pint
		_size += 1 // is nil
		if (*u).TestStruct.Pint != nil {
			_size += binary.MaxVarintLen64
		}
		// Strs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*u).TestStruct.Strs {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
		// StrInt
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*u).TestStruct.StrInt {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
		}

		// TestStructKey
		_size += 1 // is nil
		if (*u).TestStructKey != nil {
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len((*(*u).TestStructKey).Str)
		}
		// Time
		_size += 16
		// Struct
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*u).Struct.Str)

		// Structs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*u).Structs {
			_ = _e
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_e.Str)
			// Structs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _e.Structs {
				_ = _e
				_size += 1 // is nil
				if _e != nil {
					// Int
					_size += binary.MaxVarintLen64
					// Str
					_size += binary.MaxVarintLen64 + len((*_e).Str)
				}
			}

		}
	}
	return _size
}

func (u *Unnamed) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if u == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// int
		_n += binary.PutVarint(out[_n:], int64((*u).int))
		// uint
		if (*u).uint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutUvarint(out[_n:], uint64((*(*u).uint)))
		}
		// TestStruct
		// Int
		_n += binary.PutVarint(out[_n:], int64((*u).TestStruct.Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*u).TestStruct.Str)))
		_n += copy(out[_n:], (*u).TestStruct.Str)
		// Pint
		if (*u).TestStruct.Pint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64((*(*u).TestStruct.Pint)))
		}
		// Strs
		if (*u).TestStruct.Strs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*u).TestStruct.Strs)))
			for _, _e := range (*u).TestStruct.Strs {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
		// StrInt
		if (*u).TestStruct.StrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*u).TestStruct.StrInt)))
			for _k, _v := range (*u).TestStruct.StrInt {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				_n += binary.PutVarint(out[_n:], int64(_v))
			}
		}

		// TestStructKey
		if (*u).TestStructKey == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			// Int
			_n += binary.PutVarint(out[_n:], int64((*(*u).TestStructKey).Int))
			// Str
			_n += binary.PutVarint(out[_n:], int64(len((*(*u).TestStructKey).Str)))
			_n += copy(out[_n:], (*(*u).TestStructKey).Str)

		}
		// Time
		ƒçuå_Time, err := _timeMarshalBinary((*u).Time, out[_n:])
		if err != nil {
			return 0, err
		}
		_n += ƒçuå_Time
		// Struct
		// Int
		_n += binary.PutVarint(out[_n:], int64((*u).Struct.Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*u).Struct.Str)))
		_n += copy(out[_n:], (*u).Struct.Str)

		// Structs
		if (*u).Structs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*u).Structs)))
			for _, _e := range (*u).Structs {
				_ = _e
				// Int
				_n += binary.PutVarint(out[_n:], int64(_e.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_e.Str)))
				_n += copy(out[_n:], _e.Str)
				// Structs
				if _e.Structs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.Structs)))
					for _, _e := range _e.Structs {
						_ = _e
						if _e == nil {
							out[_n] = 0
							_n += 1
						} else {
							out[_n] = 1
							_n += 1
							// Int
							_n += binary.PutVarint(out[_n:], int64((*_e).Int))
							// Str
							_n += binary.PutVarint(out[_n:], int64(len((*_e).Str)))
							_n += copy(out[_n:], (*_e).Str)

						}
					}
				}

			}
		}

	}

	return _n, nil
}

func DecodeUnnamed(in []byte, u *Unnamed) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// int
	_ƒçuå_int, _ƒçuå_intSize := binary.Varint(in[_n:])
	(*u).int = int(_ƒçuå_int)
	_n += _ƒçuå_intSize
	// uint
	if in[_n] == 0 {
		_n += 1
		(*u).uint = nil
	} else {
		_n += 1
		var _p_ƒçuå_uint uint
		__p_ƒçuå_uint, __p_ƒçuå_uintSize := binary.Uvarint(in[_n:])
		_p_ƒçuå_uint = uint(__p_ƒçuå_uint)
		_n += __p_ƒçuå_uintSize
		(*u).uint = &_p_ƒçuå_uint
	}
	// TestStruct
	// Int
	_ƒçuå_TestStruct_Int, _ƒçuå_TestStruct_IntSize := binary.Varint(in[_n:])
	(*u).TestStruct.Int = int(_ƒçuå_TestStruct_Int)
	_n += _ƒçuå_TestStruct_IntSize
	// Str
	_ƒçuå_TestStruct_StrLen, _ƒçuå_TestStruct_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçuå_TestStruct_StrLenSize
	(*u).TestStruct.Str = string(in[_n : _n+int(_ƒçuå_TestStruct_StrLen)])
	_n += int(_ƒçuå_TestStruct_StrLen)
	// Pint
	if in[_n] == 0 {
		_n += 1
		(*u).TestStruct.Pint = nil
	} else {
		_n += 1
		var _p_ƒçuå_TestStruct_Pint int
		__p_ƒçuå_TestStruct_Pint, __p_ƒçuå_TestStruct_PintSize := binary.Varint(in[_n:])
		_p_ƒçuå_TestStruct_Pint = int(__p_ƒçuå_TestStruct_Pint)
		_n += __p_ƒçuå_TestStruct_PintSize
		(*u).TestStruct.Pint = &_p_ƒçuå_TestStruct_Pint
	}
	// Strs
	if in[_n] == 0 {
		_n += 1
		(*u).TestStruct.Strs = nil
	} else {
		_n += 1
		_ƒçuå_TestStruct_StrsLen, _ƒçuå_TestStruct_StrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçuå_TestStruct_StrsLenSize
		(*u).TestStruct.Strs = make([]string, _ƒçuå_TestStruct_StrsLen)
		for _i := int64(0); _i < _ƒçuå_TestStruct_StrsLen; _i++ {
			var _e_ƒçuå_TestStruct_Strs string
			__e_ƒçuå_TestStruct_StrsLen, __e_ƒçuå_TestStruct_StrsLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçuå_TestStruct_StrsLenSize
			_e_ƒçuå_TestStruct_Strs = string(in[_n : _n+int(__e_ƒçuå_TestStruct_StrsLen)])
			_n += int(__e_ƒçuå_TestStruct_StrsLen)
			(*u).TestStruct.Strs[_i] = _e_ƒçuå_TestStruct_Strs
		}
	}
	// StrInt
	if in[_n] == 0 {
		_n += 1
		(*u).TestStruct.StrInt = nil
	} else {
		_n += 1
		_ƒçuå_TestStruct_StrIntLen, _ƒçuå_TestStruct_StrIntLenSize := binary.Varint(in[_n:])
		_n += _ƒçuå_TestStruct_StrIntLenSize
		(*u).TestStruct.StrInt = make(map[string]int, _ƒçuå_TestStruct_StrIntLen)
		for _i := int64(0); _i < _ƒçuå_TestStruct_StrIntLen; _i++ {
			var _k_ƒçuå_TestStruct_StrInt string
			var _v_ƒçuå_TestStruct_StrInt int
			__k_ƒçuå_TestStruct_StrIntLen, __k_ƒçuå_TestStruct_StrIntLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçuå_TestStruct_StrIntLenSize
			_k_ƒçuå_TestStruct_StrInt = string(in[_n : _n+int(__k_ƒçuå_TestStruct_StrIntLen)])
			_n += int(__k_ƒçuå_TestStruct_StrIntLen)
			__v_ƒçuå_TestStruct_StrInt, __v_ƒçuå_TestStruct_StrIntSize := binary.Varint(in[_n:])
			_v_ƒçuå_TestStruct_StrInt = int(__v_ƒçuå_TestStruct_StrInt)
			_n += __v_ƒçuå_TestStruct_StrIntSize
			(*u).TestStruct.StrInt[_k_ƒçuå_TestStruct_StrInt] = _v_ƒçuå_TestStruct_StrInt
		}
	}

	// TestStructKey
	if in[_n] == 0 {
		_n += 1
		(*u).TestStructKey = nil
	} else {
		_n += 1
		var _p_ƒçuå_TestStructKey TestStructKey
		// Int
		__p_ƒçuå_TestStructKey_Int, __p_ƒçuå_TestStructKey_IntSize := binary.Varint(in[_n:])
		_p_ƒçuå_TestStructKey.Int = int(__p_ƒçuå_TestStructKey_Int)
		_n += __p_ƒçuå_TestStructKey_IntSize
		// Str
		__p_ƒçuå_TestStructKey_StrLen, __p_ƒçuå_TestStructKey_StrLenSize := binary.Varint(in[_n:])
		_n += __p_ƒçuå_TestStructKey_StrLenSize
		_p_ƒçuå_TestStructKey.Str = string(in[_n : _n+int(__p_ƒçuå_TestStructKey_StrLen)])
		_n += int(__p_ƒçuå_TestStructKey_StrLen)

		(*u).TestStructKey = &_p_ƒçuå_TestStructKey
	}
	// Time
	if in[_n] == 1 {
		err = (*u).Time.UnmarshalBinary(in[_n : _n+15])
	} else {
		err = (*u).Time.UnmarshalBinary(in[_n : _n+16])
	}
	if err != nil {
		return 0, err
	}
	_n += 16
	// Struct
	// Int
	_ƒçuå_Struct_Int, _ƒçuå_Struct_IntSize := binary.Varint(in[_n:])
	(*u).Struct.Int = int(_ƒçuå_Struct_Int)
	_n += _ƒçuå_Struct_IntSize
	// Str
	_ƒçuå_Struct_StrLen, _ƒçuå_Struct_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçuå_Struct_StrLenSize
	(*u).Struct.Str = string(in[_n : _n+int(_ƒçuå_Struct_StrLen)])
	_n += int(_ƒçuå_Struct_StrLen)

	// Structs
	if in[_n] == 0 {
		_n += 1
		(*u).Structs = nil
	} else {
		_n += 1
		_ƒçuå_StructsLen, _ƒçuå_StructsLenSize := binary.Varint(in[_n:])
		_n += _ƒçuå_StructsLenSize
		(*u).Structs = make([]struct {
			Int     int
			Str     string
			Structs []*struct {
				Int int
				Str string
			}
		}, _ƒçuå_StructsLen)
		for _i := int64(0); _i < _ƒçuå_StructsLen; _i++ {
			var _e_ƒçuå_Structs struct {
				Int     int
				Str     string
				Structs []*struct {
					Int int
					Str string
				}
			}
			// Int
			__e_ƒçuå_Structs_Int, __e_ƒçuå_Structs_IntSize := binary.Varint(in[_n:])
			_e_ƒçuå_Structs.Int = int(__e_ƒçuå_Structs_Int)
			_n += __e_ƒçuå_Structs_IntSize
			// Str
			__e_ƒçuå_Structs_StrLen, __e_ƒçuå_Structs_StrLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçuå_Structs_StrLenSize
			_e_ƒçuå_Structs.Str = string(in[_n : _n+int(__e_ƒçuå_Structs_StrLen)])
			_n += int(__e_ƒçuå_Structs_StrLen)
			// Structs
			if in[_n] == 0 {
				_n += 1
				_e_ƒçuå_Structs.Structs = nil
			} else {
				_n += 1
				__e_ƒçuå_Structs_StructsLen, __e_ƒçuå_Structs_StructsLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçuå_Structs_StructsLenSize
				_e_ƒçuå_Structs.Structs = make([]*struct {
					Int int
					Str string
				}, __e_ƒçuå_Structs_StructsLen)
				for _i := int64(0); _i < __e_ƒçuå_Structs_StructsLen; _i++ {
					var _e__e_ƒçuå_Structs_Structs *struct {
						Int int
						Str string
					}
					if in[_n] == 0 {
						_n += 1
						_e__e_ƒçuå_Structs_Structs = nil
					} else {
						_n += 1
						var _p__e__e_ƒçuå_Structs_Structs struct {
							Int int
							Str string
						}
						// Int
						__p__e__e_ƒçuå_Structs_Structs_Int, __p__e__e_ƒçuå_Structs_Structs_IntSize := binary.Varint(in[_n:])
						_p__e__e_ƒçuå_Structs_Structs.Int = int(__p__e__e_ƒçuå_Structs_Structs_Int)
						_n += __p__e__e_ƒçuå_Structs_Structs_IntSize
						// Str
						__p__e__e_ƒçuå_Structs_Structs_StrLen, __p__e__e_ƒçuå_Structs_Structs_StrLenSize := binary.Varint(in[_n:])
						_n += __p__e__e_ƒçuå_Structs_Structs_StrLenSize
						_p__e__e_ƒçuå_Structs_Structs.Str = string(in[_n : _n+int(__p__e__e_ƒçuå_Structs_Structs_StrLen)])
						_n += int(__p__e__e_ƒçuå_Structs_Structs_StrLen)

						_e__e_ƒçuå_Structs_Structs = &_p__e__e_ƒçuå_Structs_Structs
					}
					_e_ƒçuå_Structs.Structs[_i] = _e__e_ƒçuå_Structs_Structs
				}
			}

			(*u).Structs[_i] = _e_ƒçuå_Structs
		}
	}

	return _n, nil
}

func (s *StrAlias) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *StrAlias) Decode(in []byte) (*StrAlias, error) {
	_, err := DecodeStrAlias(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *StrAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		_size += binary.MaxVarintLen64 + len((*s))
	}
	return _size
}

func (s *StrAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		_n += binary.PutVarint(out[_n:], int64(len((*s))))
		_n += copy(out[_n:], (*s))
	}

	return _n, nil
}

func DecodeStrAlias(in []byte, s *StrAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	_ƒçsåLen, _ƒçsåLenSize := binary.Varint(in[_n:])
	_n += _ƒçsåLenSize
	(*s) = StrAlias(in[_n : _n+int(_ƒçsåLen)])
	_n += int(_ƒçsåLen)
	return _n, nil
}

func (i *IntAlias) Encode() ([]byte, error) {
	out := make([]byte, i.MaxSize())

	_n, err := i.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (i *IntAlias) Decode(in []byte) (*IntAlias, error) {
	_, err := DecodeIntAlias(in, i)
	if err != nil {
		return i, err
	}

	return i, nil
}

func (i *IntAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if i != nil {
		_size += binary.MaxVarintLen64
	}
	return _size
}

func (i *IntAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if i == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		_n += binary.PutVarint(out[_n:], int64((*i)))
	}

	return _n, nil
}

func DecodeIntAlias(in []byte, i *IntAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	_ƒçiå, _ƒçiåSize := binary.Varint(in[_n:])
	(*i) = IntAlias(_ƒçiå)
	_n += _ƒçiåSize
	return _n, nil
}

func (s *StrsAlias) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *StrsAlias) Decode(in []byte) (*StrsAlias, error) {
	_, err := DecodeStrsAlias(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *StrsAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range *s {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
	}
	return _size
}

func (s *StrsAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*s) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s))))
			for _, _e := range *s {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
	}

	return _n, nil
}

func DecodeStrsAlias(in []byte, s *StrsAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*s) = nil
	} else {
		_n += 1
		_ƒçsåLen, _ƒçsåLenSize := binary.Varint(in[_n:])
		_n += _ƒçsåLenSize
		(*s) = make([]string, _ƒçsåLen)
		for _i := int64(0); _i < _ƒçsåLen; _i++ {
			var _e_ƒçså string
			__e_ƒçsåLen, __e_ƒçsåLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçsåLenSize
			_e_ƒçså = string(in[_n : _n+int(__e_ƒçsåLen)])
			_n += int(__e_ƒçsåLen)
			(*s)[_i] = _e_ƒçså
		}
	}
	return _n, nil
}

func (p *PintsAlias) Encode() ([]byte, error) {
	out := make([]byte, p.MaxSize())

	_n, err := p.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (p *PintsAlias) Decode(in []byte) (*PintsAlias, error) {
	_, err := DecodePintsAlias(in, p)
	if err != nil {
		return p, err
	}

	return p, nil
}

func (p *PintsAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if p != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range *p {
			_ = _e
			_size += 1 // is nil
			if _e != nil {
				_size += binary.MaxVarintLen64
			}
		}
	}
	return _size
}

func (p *PintsAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if p == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*p) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*p))))
			for _, _e := range *p {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_e)))
				}
			}
		}
	}

	return _n, nil
}

func DecodePintsAlias(in []byte, p *PintsAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*p) = nil
	} else {
		_n += 1
		_ƒçpåLen, _ƒçpåLenSize := binary.Varint(in[_n:])
		_n += _ƒçpåLenSize
		(*p) = make([]*int, _ƒçpåLen)
		for _i := int64(0); _i < _ƒçpåLen; _i++ {
			var _e_ƒçpå *int
			if in[_n] == 0 {
				_n += 1
				_e_ƒçpå = nil
			} else {
				_n += 1
				var _p__e_ƒçpå int
				__p__e_ƒçpå, __p__e_ƒçpåSize := binary.Varint(in[_n:])
				_p__e_ƒçpå = int(__p__e_ƒçpå)
				_n += __p__e_ƒçpåSize
				_e_ƒçpå = &_p__e_ƒçpå
			}
			(*p)[_i] = _e_ƒçpå
		}
	}
	return _n, nil
}

func (i *IntsAlias) Encode() ([]byte, error) {
	out := make([]byte, i.MaxSize())

	_n, err := i.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (i *IntsAlias) Decode(in []byte) (*IntsAlias, error) {
	_, err := DecodeIntsAlias(in, i)
	if err != nil {
		return i, err
	}

	return i, nil
}

func (i *IntsAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if i != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range *i {
			_ = _e
			_size += binary.MaxVarintLen64
		}
	}
	return _size
}

func (i *IntsAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if i == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*i) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*i))))
			for _, _e := range *i {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(_e))
			}
		}
	}

	return _n, nil
}

func DecodeIntsAlias(in []byte, i *IntsAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*i) = nil
	} else {
		_n += 1
		_ƒçiåLen, _ƒçiåLenSize := binary.Varint(in[_n:])
		_n += _ƒçiåLenSize
		(*i) = make([]IntAlias, _ƒçiåLen)
		for _i := int64(0); _i < _ƒçiåLen; _i++ {
			var _e_ƒçiå IntAlias
			__e_ƒçiå, __e_ƒçiåSize := binary.Varint(in[_n:])
			_e_ƒçiå = IntAlias(__e_ƒçiå)
			_n += __e_ƒçiåSize
			(*i)[_i] = _e_ƒçiå
		}
	}
	return _n, nil
}

func (t *TestStructAlias) Encode() ([]byte, error) {
	out := make([]byte, t.MaxSize())

	_n, err := t.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (t *TestStructAlias) Decode(in []byte) (*TestStructAlias, error) {
	_, err := DecodeTestStructAlias(in, t)
	if err != nil {
		return t, err
	}

	return t, nil
}

func (t *TestStructAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if t != nil {
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*t).Str)
		// Pint
		_size += 1 // is nil
		if (*t).Pint != nil {
			_size += binary.MaxVarintLen64
		}
		// Strs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*t).Strs {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
		// StrInt
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*t).StrInt {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
		}
	}
	return _size
}

func (t *TestStructAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if t == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Int
		_n += binary.PutVarint(out[_n:], int64((*t).Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*t).Str)))
		_n += copy(out[_n:], (*t).Str)
		// Pint
		if (*t).Pint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64((*(*t).Pint)))
		}
		// Strs
		if (*t).Strs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*t).Strs)))
			for _, _e := range (*t).Strs {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
		// StrInt
		if (*t).StrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*t).StrInt)))
			for _k, _v := range (*t).StrInt {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				_n += binary.PutVarint(out[_n:], int64(_v))
			}
		}

	}

	return _n, nil
}

func DecodeTestStructAlias(in []byte, t *TestStructAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Int
	_ƒçtå_Int, _ƒçtå_IntSize := binary.Varint(in[_n:])
	(*t).Int = int(_ƒçtå_Int)
	_n += _ƒçtå_IntSize
	// Str
	_ƒçtå_StrLen, _ƒçtå_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçtå_StrLenSize
	(*t).Str = string(in[_n : _n+int(_ƒçtå_StrLen)])
	_n += int(_ƒçtå_StrLen)
	// Pint
	if in[_n] == 0 {
		_n += 1
		(*t).Pint = nil
	} else {
		_n += 1
		var _p_ƒçtå_Pint int
		__p_ƒçtå_Pint, __p_ƒçtå_PintSize := binary.Varint(in[_n:])
		_p_ƒçtå_Pint = int(__p_ƒçtå_Pint)
		_n += __p_ƒçtå_PintSize
		(*t).Pint = &_p_ƒçtå_Pint
	}
	// Strs
	if in[_n] == 0 {
		_n += 1
		(*t).Strs = nil
	} else {
		_n += 1
		_ƒçtå_StrsLen, _ƒçtå_StrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçtå_StrsLenSize
		(*t).Strs = make([]string, _ƒçtå_StrsLen)
		for _i := int64(0); _i < _ƒçtå_StrsLen; _i++ {
			var _e_ƒçtå_Strs string
			__e_ƒçtå_StrsLen, __e_ƒçtå_StrsLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçtå_StrsLenSize
			_e_ƒçtå_Strs = string(in[_n : _n+int(__e_ƒçtå_StrsLen)])
			_n += int(__e_ƒçtå_StrsLen)
			(*t).Strs[_i] = _e_ƒçtå_Strs
		}
	}
	// StrInt
	if in[_n] == 0 {
		_n += 1
		(*t).StrInt = nil
	} else {
		_n += 1
		_ƒçtå_StrIntLen, _ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
		_n += _ƒçtå_StrIntLenSize
		(*t).StrInt = make(map[string]int, _ƒçtå_StrIntLen)
		for _i := int64(0); _i < _ƒçtå_StrIntLen; _i++ {
			var _k_ƒçtå_StrInt string
			var _v_ƒçtå_StrInt int
			__k_ƒçtå_StrIntLen, __k_ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçtå_StrIntLenSize
			_k_ƒçtå_StrInt = string(in[_n : _n+int(__k_ƒçtå_StrIntLen)])
			_n += int(__k_ƒçtå_StrIntLen)
			__v_ƒçtå_StrInt, __v_ƒçtå_StrIntSize := binary.Varint(in[_n:])
			_v_ƒçtå_StrInt = int(__v_ƒçtå_StrInt)
			_n += __v_ƒçtå_StrIntSize
			(*t).StrInt[_k_ƒçtå_StrInt] = _v_ƒçtå_StrInt
		}
	}

	return _n, nil
}

func (t *TestStructs) Encode() ([]byte, error) {
	out := make([]byte, t.MaxSize())

	_n, err := t.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (t *TestStructs) Decode(in []byte) (*TestStructs, error) {
	_, err := DecodeTestStructs(in, t)
	if err != nil {
		return t, err
	}

	return t, nil
}

func (t *TestStructs) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if t != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range *t {
			_ = _e
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_e.Str)
			// Pint
			_size += 1 // is nil
			if _e.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _e.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _e.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
	}
	return _size
}

func (t *TestStructs) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if t == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*t) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*t))))
			for _, _e := range *t {
				_ = _e
				// Int
				_n += binary.PutVarint(out[_n:], int64(_e.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_e.Str)))
				_n += copy(out[_n:], _e.Str)
				// Pint
				if _e.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_e.Pint)))
				}
				// Strs
				if _e.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.Strs)))
					for _, _e := range _e.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _e.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.StrInt)))
					for _k, _v := range _e.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}
	}

	return _n, nil
}

func DecodeTestStructs(in []byte, t *TestStructs) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*t) = nil
	} else {
		_n += 1
		_ƒçtåLen, _ƒçtåLenSize := binary.Varint(in[_n:])
		_n += _ƒçtåLenSize
		(*t) = make([]TestStruct, _ƒçtåLen)
		for _i := int64(0); _i < _ƒçtåLen; _i++ {
			var _e_ƒçtå TestStruct
			// Int
			__e_ƒçtå_Int, __e_ƒçtå_IntSize := binary.Varint(in[_n:])
			_e_ƒçtå.Int = int(__e_ƒçtå_Int)
			_n += __e_ƒçtå_IntSize
			// Str
			__e_ƒçtå_StrLen, __e_ƒçtå_StrLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçtå_StrLenSize
			_e_ƒçtå.Str = string(in[_n : _n+int(__e_ƒçtå_StrLen)])
			_n += int(__e_ƒçtå_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_e_ƒçtå.Pint = nil
			} else {
				_n += 1
				var _p__e_ƒçtå_Pint int
				__p__e_ƒçtå_Pint, __p__e_ƒçtå_PintSize := binary.Varint(in[_n:])
				_p__e_ƒçtå_Pint = int(__p__e_ƒçtå_Pint)
				_n += __p__e_ƒçtå_PintSize
				_e_ƒçtå.Pint = &_p__e_ƒçtå_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_e_ƒçtå.Strs = nil
			} else {
				_n += 1
				__e_ƒçtå_StrsLen, __e_ƒçtå_StrsLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçtå_StrsLenSize
				_e_ƒçtå.Strs = make([]string, __e_ƒçtå_StrsLen)
				for _i := int64(0); _i < __e_ƒçtå_StrsLen; _i++ {
					var _e__e_ƒçtå_Strs string
					__e__e_ƒçtå_StrsLen, __e__e_ƒçtå_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__e_ƒçtå_StrsLenSize
					_e__e_ƒçtå_Strs = string(in[_n : _n+int(__e__e_ƒçtå_StrsLen)])
					_n += int(__e__e_ƒçtå_StrsLen)
					_e_ƒçtå.Strs[_i] = _e__e_ƒçtå_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_e_ƒçtå.StrInt = nil
			} else {
				_n += 1
				__e_ƒçtå_StrIntLen, __e_ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçtå_StrIntLenSize
				_e_ƒçtå.StrInt = make(map[string]int, __e_ƒçtå_StrIntLen)
				for _i := int64(0); _i < __e_ƒçtå_StrIntLen; _i++ {
					var _k__e_ƒçtå_StrInt string
					var _v__e_ƒçtå_StrInt int
					__k__e_ƒçtå_StrIntLen, __k__e_ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__e_ƒçtå_StrIntLenSize
					_k__e_ƒçtå_StrInt = string(in[_n : _n+int(__k__e_ƒçtå_StrIntLen)])
					_n += int(__k__e_ƒçtå_StrIntLen)
					__v__e_ƒçtå_StrInt, __v__e_ƒçtå_StrIntSize := binary.Varint(in[_n:])
					_v__e_ƒçtå_StrInt = int(__v__e_ƒçtå_StrInt)
					_n += __v__e_ƒçtå_StrIntSize
					_e_ƒçtå.StrInt[_k__e_ƒçtå_StrInt] = _v__e_ƒçtå_StrInt
				}
			}

			(*t)[_i] = _e_ƒçtå
		}
	}
	return _n, nil
}

func (p *PtestStructs) Encode() ([]byte, error) {
	out := make([]byte, p.MaxSize())

	_n, err := p.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (p *PtestStructs) Decode(in []byte) (*PtestStructs, error) {
	_, err := DecodePtestStructs(in, p)
	if err != nil {
		return p, err
	}

	return p, nil
}

func (p *PtestStructs) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if p != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range *p {
			_ = _e
			_size += 1 // is nil
			if _e != nil {
				// Int
				_size += binary.MaxVarintLen64
				// Str
				_size += binary.MaxVarintLen64 + len((*_e).Str)
				// Pint
				_size += 1 // is nil
				if (*_e).Pint != nil {
					_size += binary.MaxVarintLen64
				}
				// Strs
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _, _e := range (*_e).Strs {
					_ = _e
					_size += binary.MaxVarintLen64 + len(_e)
				}
				// StrInt
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _k, _v := range (*_e).StrInt {
					_, _ = _k, _v
					_size += binary.MaxVarintLen64 + len(_k)
					_size += binary.MaxVarintLen64
				}
			}
		}
	}
	return _size
}

func (p *PtestStructs) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if p == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*p) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*p))))
			for _, _e := range *p {
				_ = _e
				if _e == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					// Int
					_n += binary.PutVarint(out[_n:], int64((*_e).Int))
					// Str
					_n += binary.PutVarint(out[_n:], int64(len((*_e).Str)))
					_n += copy(out[_n:], (*_e).Str)
					// Pint
					if (*_e).Pint == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64((*(*_e).Pint)))
					}
					// Strs
					if (*_e).Strs == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_e).Strs)))
						for _, _e := range (*_e).Strs {
							_ = _e
							_n += binary.PutVarint(out[_n:], int64(len(_e)))
							_n += copy(out[_n:], _e)
						}
					}
					// StrInt
					if (*_e).StrInt == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_e).StrInt)))
						for _k, _v := range (*_e).StrInt {
							_, _ = _k, _v
							_n += binary.PutVarint(out[_n:], int64(len(_k)))
							_n += copy(out[_n:], _k)
							_n += binary.PutVarint(out[_n:], int64(_v))
						}
					}

				}
			}
		}
	}

	return _n, nil
}

func DecodePtestStructs(in []byte, p *PtestStructs) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*p) = nil
	} else {
		_n += 1
		_ƒçpåLen, _ƒçpåLenSize := binary.Varint(in[_n:])
		_n += _ƒçpåLenSize
		(*p) = make([]*TestStruct, _ƒçpåLen)
		for _i := int64(0); _i < _ƒçpåLen; _i++ {
			var _e_ƒçpå *TestStruct
			if in[_n] == 0 {
				_n += 1
				_e_ƒçpå = nil
			} else {
				_n += 1
				var _p__e_ƒçpå TestStruct
				// Int
				__p__e_ƒçpå_Int, __p__e_ƒçpå_IntSize := binary.Varint(in[_n:])
				_p__e_ƒçpå.Int = int(__p__e_ƒçpå_Int)
				_n += __p__e_ƒçpå_IntSize
				// Str
				__p__e_ƒçpå_StrLen, __p__e_ƒçpå_StrLenSize := binary.Varint(in[_n:])
				_n += __p__e_ƒçpå_StrLenSize
				_p__e_ƒçpå.Str = string(in[_n : _n+int(__p__e_ƒçpå_StrLen)])
				_n += int(__p__e_ƒçpå_StrLen)
				// Pint
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçpå.Pint = nil
				} else {
					_n += 1
					var _p__p__e_ƒçpå_Pint int
					__p__p__e_ƒçpå_Pint, __p__p__e_ƒçpå_PintSize := binary.Varint(in[_n:])
					_p__p__e_ƒçpå_Pint = int(__p__p__e_ƒçpå_Pint)
					_n += __p__p__e_ƒçpå_PintSize
					_p__e_ƒçpå.Pint = &_p__p__e_ƒçpå_Pint
				}
				// Strs
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçpå.Strs = nil
				} else {
					_n += 1
					__p__e_ƒçpå_StrsLen, __p__e_ƒçpå_StrsLenSize := binary.Varint(in[_n:])
					_n += __p__e_ƒçpå_StrsLenSize
					_p__e_ƒçpå.Strs = make([]string, __p__e_ƒçpå_StrsLen)
					for _i := int64(0); _i < __p__e_ƒçpå_StrsLen; _i++ {
						var _e__p__e_ƒçpå_Strs string
						__e__p__e_ƒçpå_StrsLen, __e__p__e_ƒçpå_StrsLenSize := binary.Varint(in[_n:])
						_n += __e__p__e_ƒçpå_StrsLenSize
						_e__p__e_ƒçpå_Strs = string(in[_n : _n+int(__e__p__e_ƒçpå_StrsLen)])
						_n += int(__e__p__e_ƒçpå_StrsLen)
						_p__e_ƒçpå.Strs[_i] = _e__p__e_ƒçpå_Strs
					}
				}
				// StrInt
				if in[_n] == 0 {
					_n += 1
					_p__e_ƒçpå.StrInt = nil
				} else {
					_n += 1
					__p__e_ƒçpå_StrIntLen, __p__e_ƒçpå_StrIntLenSize := binary.Varint(in[_n:])
					_n += __p__e_ƒçpå_StrIntLenSize
					_p__e_ƒçpå.StrInt = make(map[string]int, __p__e_ƒçpå_StrIntLen)
					for _i := int64(0); _i < __p__e_ƒçpå_StrIntLen; _i++ {
						var _k__p__e_ƒçpå_StrInt string
						var _v__p__e_ƒçpå_StrInt int
						__k__p__e_ƒçpå_StrIntLen, __k__p__e_ƒçpå_StrIntLenSize := binary.Varint(in[_n:])
						_n += __k__p__e_ƒçpå_StrIntLenSize
						_k__p__e_ƒçpå_StrInt = string(in[_n : _n+int(__k__p__e_ƒçpå_StrIntLen)])
						_n += int(__k__p__e_ƒçpå_StrIntLen)
						__v__p__e_ƒçpå_StrInt, __v__p__e_ƒçpå_StrIntSize := binary.Varint(in[_n:])
						_v__p__e_ƒçpå_StrInt = int(__v__p__e_ƒçpå_StrInt)
						_n += __v__p__e_ƒçpå_StrIntSize
						_p__e_ƒçpå.StrInt[_k__p__e_ƒçpå_StrInt] = _v__p__e_ƒçpå_StrInt
					}
				}

				_e_ƒçpå = &_p__e_ƒçpå
			}
			(*p)[_i] = _e_ƒçpå
		}
	}
	return _n, nil
}

func (s *StrTestStruct) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *StrTestStruct) Decode(in []byte) (*StrTestStruct, error) {
	_, err := DecodeStrTestStruct(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *StrTestStruct) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range *s {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_v.Str)
			// Pint
			_size += 1 // is nil
			if _v.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _v.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _v.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
	}
	return _size
}

func (s *StrTestStruct) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*s) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s))))
			for _k, _v := range *s {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				// Int
				_n += binary.PutVarint(out[_n:], int64(_v.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_v.Str)))
				_n += copy(out[_n:], _v.Str)
				// Pint
				if _v.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_v.Pint)))
				}
				// Strs
				if _v.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.Strs)))
					for _, _e := range _v.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _v.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.StrInt)))
					for _k, _v := range _v.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}
	}

	return _n, nil
}

func DecodeStrTestStruct(in []byte, s *StrTestStruct) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*s) = nil
	} else {
		_n += 1
		_ƒçsåLen, _ƒçsåLenSize := binary.Varint(in[_n:])
		_n += _ƒçsåLenSize
		(*s) = make(map[string]TestStruct, _ƒçsåLen)
		for _i := int64(0); _i < _ƒçsåLen; _i++ {
			var _k_ƒçså string
			var _v_ƒçså TestStruct
			__k_ƒçsåLen, __k_ƒçsåLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçsåLenSize
			_k_ƒçså = string(in[_n : _n+int(__k_ƒçsåLen)])
			_n += int(__k_ƒçsåLen)
			// Int
			__v_ƒçså_Int, __v_ƒçså_IntSize := binary.Varint(in[_n:])
			_v_ƒçså.Int = int(__v_ƒçså_Int)
			_n += __v_ƒçså_IntSize
			// Str
			__v_ƒçså_StrLen, __v_ƒçså_StrLenSize := binary.Varint(in[_n:])
			_n += __v_ƒçså_StrLenSize
			_v_ƒçså.Str = string(in[_n : _n+int(__v_ƒçså_StrLen)])
			_n += int(__v_ƒçså_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_v_ƒçså.Pint = nil
			} else {
				_n += 1
				var _p__v_ƒçså_Pint int
				__p__v_ƒçså_Pint, __p__v_ƒçså_PintSize := binary.Varint(in[_n:])
				_p__v_ƒçså_Pint = int(__p__v_ƒçså_Pint)
				_n += __p__v_ƒçså_PintSize
				_v_ƒçså.Pint = &_p__v_ƒçså_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_v_ƒçså.Strs = nil
			} else {
				_n += 1
				__v_ƒçså_StrsLen, __v_ƒçså_StrsLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçså_StrsLenSize
				_v_ƒçså.Strs = make([]string, __v_ƒçså_StrsLen)
				for _i := int64(0); _i < __v_ƒçså_StrsLen; _i++ {
					var _e__v_ƒçså_Strs string
					__e__v_ƒçså_StrsLen, __e__v_ƒçså_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__v_ƒçså_StrsLenSize
					_e__v_ƒçså_Strs = string(in[_n : _n+int(__e__v_ƒçså_StrsLen)])
					_n += int(__e__v_ƒçså_StrsLen)
					_v_ƒçså.Strs[_i] = _e__v_ƒçså_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_v_ƒçså.StrInt = nil
			} else {
				_n += 1
				__v_ƒçså_StrIntLen, __v_ƒçså_StrIntLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçså_StrIntLenSize
				_v_ƒçså.StrInt = make(map[string]int, __v_ƒçså_StrIntLen)
				for _i := int64(0); _i < __v_ƒçså_StrIntLen; _i++ {
					var _k__v_ƒçså_StrInt string
					var _v__v_ƒçså_StrInt int
					__k__v_ƒçså_StrIntLen, __k__v_ƒçså_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__v_ƒçså_StrIntLenSize
					_k__v_ƒçså_StrInt = string(in[_n : _n+int(__k__v_ƒçså_StrIntLen)])
					_n += int(__k__v_ƒçså_StrIntLen)
					__v__v_ƒçså_StrInt, __v__v_ƒçså_StrIntSize := binary.Varint(in[_n:])
					_v__v_ƒçså_StrInt = int(__v__v_ƒçså_StrInt)
					_n += __v__v_ƒçså_StrIntSize
					_v_ƒçså.StrInt[_k__v_ƒçså_StrInt] = _v__v_ƒçså_StrInt
				}
			}

			(*s)[_k_ƒçså] = _v_ƒçså
		}
	}
	return _n, nil
}

func (s *StrTestStructAlias) Encode() ([]byte, error) {
	out := make([]byte, s.MaxSize())

	_n, err := s.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (s *StrTestStructAlias) Decode(in []byte) (*StrTestStructAlias, error) {
	_, err := DecodeStrTestStructAlias(in, s)
	if err != nil {
		return s, err
	}

	return s, nil
}

func (s *StrTestStructAlias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if s != nil {
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range *s {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += 1 // is nil
			if _v != nil {
				// Int
				_size += binary.MaxVarintLen64
				// Str
				_size += binary.MaxVarintLen64 + len((*_v).Str)
				// Pint
				_size += 1 // is nil
				if (*_v).Pint != nil {
					_size += binary.MaxVarintLen64
				}
				// Strs
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _, _e := range (*_v).Strs {
					_ = _e
					_size += binary.MaxVarintLen64 + len(_e)
				}
				// StrInt
				_size += binary.MaxVarintLen64
				_size += 1 // is nil
				for _k, _v := range (*_v).StrInt {
					_, _ = _k, _v
					_size += binary.MaxVarintLen64 + len(_k)
					_size += binary.MaxVarintLen64
				}
			}
		}
	}
	return _size
}

func (s *StrTestStructAlias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if s == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		if (*s) == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*s))))
			for _k, _v := range *s {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				if _v == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					// Int
					_n += binary.PutVarint(out[_n:], int64((*_v).Int))
					// Str
					_n += binary.PutVarint(out[_n:], int64(len((*_v).Str)))
					_n += copy(out[_n:], (*_v).Str)
					// Pint
					if (*_v).Pint == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64((*(*_v).Pint)))
					}
					// Strs
					if (*_v).Strs == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_v).Strs)))
						for _, _e := range (*_v).Strs {
							_ = _e
							_n += binary.PutVarint(out[_n:], int64(len(_e)))
							_n += copy(out[_n:], _e)
						}
					}
					// StrInt
					if (*_v).StrInt == nil {
						out[_n] = 0
						_n += 1
					} else {
						out[_n] = 1
						_n += 1
						_n += binary.PutVarint(out[_n:], int64(len((*_v).StrInt)))
						for _k, _v := range (*_v).StrInt {
							_, _ = _k, _v
							_n += binary.PutVarint(out[_n:], int64(len(_k)))
							_n += copy(out[_n:], _k)
							_n += binary.PutVarint(out[_n:], int64(_v))
						}
					}

				}
			}
		}
	}

	return _n, nil
}

func DecodeStrTestStructAlias(in []byte, s *StrTestStructAlias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	if in[_n] == 0 {
		_n += 1
		(*s) = nil
	} else {
		_n += 1
		_ƒçsåLen, _ƒçsåLenSize := binary.Varint(in[_n:])
		_n += _ƒçsåLenSize
		(*s) = make(map[StrAlias]*TestStructAlias, _ƒçsåLen)
		for _i := int64(0); _i < _ƒçsåLen; _i++ {
			var _k_ƒçså StrAlias
			var _v_ƒçså *TestStructAlias
			__k_ƒçsåLen, __k_ƒçsåLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçsåLenSize
			_k_ƒçså = StrAlias(in[_n : _n+int(__k_ƒçsåLen)])
			_n += int(__k_ƒçsåLen)
			if in[_n] == 0 {
				_n += 1
				_v_ƒçså = nil
			} else {
				_n += 1
				var _p__v_ƒçså TestStructAlias
				// Int
				__p__v_ƒçså_Int, __p__v_ƒçså_IntSize := binary.Varint(in[_n:])
				_p__v_ƒçså.Int = int(__p__v_ƒçså_Int)
				_n += __p__v_ƒçså_IntSize
				// Str
				__p__v_ƒçså_StrLen, __p__v_ƒçså_StrLenSize := binary.Varint(in[_n:])
				_n += __p__v_ƒçså_StrLenSize
				_p__v_ƒçså.Str = string(in[_n : _n+int(__p__v_ƒçså_StrLen)])
				_n += int(__p__v_ƒçså_StrLen)
				// Pint
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçså.Pint = nil
				} else {
					_n += 1
					var _p__p__v_ƒçså_Pint int
					__p__p__v_ƒçså_Pint, __p__p__v_ƒçså_PintSize := binary.Varint(in[_n:])
					_p__p__v_ƒçså_Pint = int(__p__p__v_ƒçså_Pint)
					_n += __p__p__v_ƒçså_PintSize
					_p__v_ƒçså.Pint = &_p__p__v_ƒçså_Pint
				}
				// Strs
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçså.Strs = nil
				} else {
					_n += 1
					__p__v_ƒçså_StrsLen, __p__v_ƒçså_StrsLenSize := binary.Varint(in[_n:])
					_n += __p__v_ƒçså_StrsLenSize
					_p__v_ƒçså.Strs = make([]string, __p__v_ƒçså_StrsLen)
					for _i := int64(0); _i < __p__v_ƒçså_StrsLen; _i++ {
						var _e__p__v_ƒçså_Strs string
						__e__p__v_ƒçså_StrsLen, __e__p__v_ƒçså_StrsLenSize := binary.Varint(in[_n:])
						_n += __e__p__v_ƒçså_StrsLenSize
						_e__p__v_ƒçså_Strs = string(in[_n : _n+int(__e__p__v_ƒçså_StrsLen)])
						_n += int(__e__p__v_ƒçså_StrsLen)
						_p__v_ƒçså.Strs[_i] = _e__p__v_ƒçså_Strs
					}
				}
				// StrInt
				if in[_n] == 0 {
					_n += 1
					_p__v_ƒçså.StrInt = nil
				} else {
					_n += 1
					__p__v_ƒçså_StrIntLen, __p__v_ƒçså_StrIntLenSize := binary.Varint(in[_n:])
					_n += __p__v_ƒçså_StrIntLenSize
					_p__v_ƒçså.StrInt = make(map[string]int, __p__v_ƒçså_StrIntLen)
					for _i := int64(0); _i < __p__v_ƒçså_StrIntLen; _i++ {
						var _k__p__v_ƒçså_StrInt string
						var _v__p__v_ƒçså_StrInt int
						__k__p__v_ƒçså_StrIntLen, __k__p__v_ƒçså_StrIntLenSize := binary.Varint(in[_n:])
						_n += __k__p__v_ƒçså_StrIntLenSize
						_k__p__v_ƒçså_StrInt = string(in[_n : _n+int(__k__p__v_ƒçså_StrIntLen)])
						_n += int(__k__p__v_ƒçså_StrIntLen)
						__v__p__v_ƒçså_StrInt, __v__p__v_ƒçså_StrIntSize := binary.Varint(in[_n:])
						_v__p__v_ƒçså_StrInt = int(__v__p__v_ƒçså_StrInt)
						_n += __v__p__v_ƒçså_StrIntSize
						_p__v_ƒçså.StrInt[_k__p__v_ƒçså_StrInt] = _v__p__v_ƒçså_StrInt
					}
				}

				_v_ƒçså = &_p__v_ƒçså
			}
			(*s)[_k_ƒçså] = _v_ƒçså
		}
	}
	return _n, nil
}

func (a *Alias) Encode() ([]byte, error) {
	out := make([]byte, a.MaxSize())

	_n, err := a.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (a *Alias) Decode(in []byte) (*Alias, error) {
	_, err := DecodeAlias(in, a)
	if err != nil {
		return a, err
	}

	return a, nil
}

func (a *Alias) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if a != nil {
		// StrAlias
		_size += binary.MaxVarintLen64 + len((*a).StrAlias)
		// intAlias
		_size += binary.MaxVarintLen64
		// TestStructAlias
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*a).TestStructAlias.Str)
		// Pint
		_size += 1 // is nil
		if (*a).TestStructAlias.Pint != nil {
			_size += binary.MaxVarintLen64
		}
		// Strs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*a).TestStructAlias.Strs {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
		// StrInt
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*a).TestStructAlias.StrInt {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
		}

		// TestStructs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*a).TestStructs {
			_ = _e
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_e.Str)
			// Pint
			_size += 1 // is nil
			if _e.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _e.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _e.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
		// StrTestStruct
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*a).StrTestStruct {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			// Int
			_size += binary.MaxVarintLen64
			// Str
			_size += binary.MaxVarintLen64 + len(_v.Str)
			// Pint
			_size += 1 // is nil
			if _v.Pint != nil {
				_size += binary.MaxVarintLen64
			}
			// Strs
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _, _e := range _v.Strs {
				_ = _e
				_size += binary.MaxVarintLen64 + len(_e)
			}
			// StrInt
			_size += binary.MaxVarintLen64
			_size += 1 // is nil
			for _k, _v := range _v.StrInt {
				_, _ = _k, _v
				_size += binary.MaxVarintLen64 + len(_k)
				_size += binary.MaxVarintLen64
			}

		}
	}
	return _size
}

func (a *Alias) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if a == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// StrAlias
		_n += binary.PutVarint(out[_n:], int64(len((*a).StrAlias)))
		_n += copy(out[_n:], (*a).StrAlias)
		// intAlias
		_n += binary.PutVarint(out[_n:], int64((*a).intAlias))
		// TestStructAlias
		// Int
		_n += binary.PutVarint(out[_n:], int64((*a).TestStructAlias.Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*a).TestStructAlias.Str)))
		_n += copy(out[_n:], (*a).TestStructAlias.Str)
		// Pint
		if (*a).TestStructAlias.Pint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64((*(*a).TestStructAlias.Pint)))
		}
		// Strs
		if (*a).TestStructAlias.Strs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*a).TestStructAlias.Strs)))
			for _, _e := range (*a).TestStructAlias.Strs {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
		// StrInt
		if (*a).TestStructAlias.StrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*a).TestStructAlias.StrInt)))
			for _k, _v := range (*a).TestStructAlias.StrInt {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				_n += binary.PutVarint(out[_n:], int64(_v))
			}
		}

		// TestStructs
		if (*a).TestStructs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*a).TestStructs)))
			for _, _e := range (*a).TestStructs {
				_ = _e
				// Int
				_n += binary.PutVarint(out[_n:], int64(_e.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_e.Str)))
				_n += copy(out[_n:], _e.Str)
				// Pint
				if _e.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_e.Pint)))
				}
				// Strs
				if _e.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.Strs)))
					for _, _e := range _e.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _e.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_e.StrInt)))
					for _k, _v := range _e.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}
		// StrTestStruct
		if (*a).StrTestStruct == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*a).StrTestStruct)))
			for _k, _v := range (*a).StrTestStruct {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				// Int
				_n += binary.PutVarint(out[_n:], int64(_v.Int))
				// Str
				_n += binary.PutVarint(out[_n:], int64(len(_v.Str)))
				_n += copy(out[_n:], _v.Str)
				// Pint
				if _v.Pint == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64((*_v.Pint)))
				}
				// Strs
				if _v.Strs == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.Strs)))
					for _, _e := range _v.Strs {
						_ = _e
						_n += binary.PutVarint(out[_n:], int64(len(_e)))
						_n += copy(out[_n:], _e)
					}
				}
				// StrInt
				if _v.StrInt == nil {
					out[_n] = 0
					_n += 1
				} else {
					out[_n] = 1
					_n += 1
					_n += binary.PutVarint(out[_n:], int64(len(_v.StrInt)))
					for _k, _v := range _v.StrInt {
						_, _ = _k, _v
						_n += binary.PutVarint(out[_n:], int64(len(_k)))
						_n += copy(out[_n:], _k)
						_n += binary.PutVarint(out[_n:], int64(_v))
					}
				}

			}
		}

	}

	return _n, nil
}

func DecodeAlias(in []byte, a *Alias) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// StrAlias
	_ƒçaå_StrAliasLen, _ƒçaå_StrAliasLenSize := binary.Varint(in[_n:])
	_n += _ƒçaå_StrAliasLenSize
	(*a).StrAlias = StrAlias(in[_n : _n+int(_ƒçaå_StrAliasLen)])
	_n += int(_ƒçaå_StrAliasLen)
	// intAlias
	_ƒçaå_intAlias, _ƒçaå_intAliasSize := binary.Varint(in[_n:])
	(*a).intAlias = IntAlias(_ƒçaå_intAlias)
	_n += _ƒçaå_intAliasSize
	// TestStructAlias
	// Int
	_ƒçaå_TestStructAlias_Int, _ƒçaå_TestStructAlias_IntSize := binary.Varint(in[_n:])
	(*a).TestStructAlias.Int = int(_ƒçaå_TestStructAlias_Int)
	_n += _ƒçaå_TestStructAlias_IntSize
	// Str
	_ƒçaå_TestStructAlias_StrLen, _ƒçaå_TestStructAlias_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçaå_TestStructAlias_StrLenSize
	(*a).TestStructAlias.Str = string(in[_n : _n+int(_ƒçaå_TestStructAlias_StrLen)])
	_n += int(_ƒçaå_TestStructAlias_StrLen)
	// Pint
	if in[_n] == 0 {
		_n += 1
		(*a).TestStructAlias.Pint = nil
	} else {
		_n += 1
		var _p_ƒçaå_TestStructAlias_Pint int
		__p_ƒçaå_TestStructAlias_Pint, __p_ƒçaå_TestStructAlias_PintSize := binary.Varint(in[_n:])
		_p_ƒçaå_TestStructAlias_Pint = int(__p_ƒçaå_TestStructAlias_Pint)
		_n += __p_ƒçaå_TestStructAlias_PintSize
		(*a).TestStructAlias.Pint = &_p_ƒçaå_TestStructAlias_Pint
	}
	// Strs
	if in[_n] == 0 {
		_n += 1
		(*a).TestStructAlias.Strs = nil
	} else {
		_n += 1
		_ƒçaå_TestStructAlias_StrsLen, _ƒçaå_TestStructAlias_StrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçaå_TestStructAlias_StrsLenSize
		(*a).TestStructAlias.Strs = make([]string, _ƒçaå_TestStructAlias_StrsLen)
		for _i := int64(0); _i < _ƒçaå_TestStructAlias_StrsLen; _i++ {
			var _e_ƒçaå_TestStructAlias_Strs string
			__e_ƒçaå_TestStructAlias_StrsLen, __e_ƒçaå_TestStructAlias_StrsLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçaå_TestStructAlias_StrsLenSize
			_e_ƒçaå_TestStructAlias_Strs = string(in[_n : _n+int(__e_ƒçaå_TestStructAlias_StrsLen)])
			_n += int(__e_ƒçaå_TestStructAlias_StrsLen)
			(*a).TestStructAlias.Strs[_i] = _e_ƒçaå_TestStructAlias_Strs
		}
	}
	// StrInt
	if in[_n] == 0 {
		_n += 1
		(*a).TestStructAlias.StrInt = nil
	} else {
		_n += 1
		_ƒçaå_TestStructAlias_StrIntLen, _ƒçaå_TestStructAlias_StrIntLenSize := binary.Varint(in[_n:])
		_n += _ƒçaå_TestStructAlias_StrIntLenSize
		(*a).TestStructAlias.StrInt = make(map[string]int, _ƒçaå_TestStructAlias_StrIntLen)
		for _i := int64(0); _i < _ƒçaå_TestStructAlias_StrIntLen; _i++ {
			var _k_ƒçaå_TestStructAlias_StrInt string
			var _v_ƒçaå_TestStructAlias_StrInt int
			__k_ƒçaå_TestStructAlias_StrIntLen, __k_ƒçaå_TestStructAlias_StrIntLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçaå_TestStructAlias_StrIntLenSize
			_k_ƒçaå_TestStructAlias_StrInt = string(in[_n : _n+int(__k_ƒçaå_TestStructAlias_StrIntLen)])
			_n += int(__k_ƒçaå_TestStructAlias_StrIntLen)
			__v_ƒçaå_TestStructAlias_StrInt, __v_ƒçaå_TestStructAlias_StrIntSize := binary.Varint(in[_n:])
			_v_ƒçaå_TestStructAlias_StrInt = int(__v_ƒçaå_TestStructAlias_StrInt)
			_n += __v_ƒçaå_TestStructAlias_StrIntSize
			(*a).TestStructAlias.StrInt[_k_ƒçaå_TestStructAlias_StrInt] = _v_ƒçaå_TestStructAlias_StrInt
		}
	}

	// TestStructs
	if in[_n] == 0 {
		_n += 1
		(*a).TestStructs = nil
	} else {
		_n += 1
		_ƒçaå_TestStructsLen, _ƒçaå_TestStructsLenSize := binary.Varint(in[_n:])
		_n += _ƒçaå_TestStructsLenSize
		(*a).TestStructs = make([]TestStruct, _ƒçaå_TestStructsLen)
		for _i := int64(0); _i < _ƒçaå_TestStructsLen; _i++ {
			var _e_ƒçaå_TestStructs TestStruct
			// Int
			__e_ƒçaå_TestStructs_Int, __e_ƒçaå_TestStructs_IntSize := binary.Varint(in[_n:])
			_e_ƒçaå_TestStructs.Int = int(__e_ƒçaå_TestStructs_Int)
			_n += __e_ƒçaå_TestStructs_IntSize
			// Str
			__e_ƒçaå_TestStructs_StrLen, __e_ƒçaå_TestStructs_StrLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçaå_TestStructs_StrLenSize
			_e_ƒçaå_TestStructs.Str = string(in[_n : _n+int(__e_ƒçaå_TestStructs_StrLen)])
			_n += int(__e_ƒçaå_TestStructs_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_e_ƒçaå_TestStructs.Pint = nil
			} else {
				_n += 1
				var _p__e_ƒçaå_TestStructs_Pint int
				__p__e_ƒçaå_TestStructs_Pint, __p__e_ƒçaå_TestStructs_PintSize := binary.Varint(in[_n:])
				_p__e_ƒçaå_TestStructs_Pint = int(__p__e_ƒçaå_TestStructs_Pint)
				_n += __p__e_ƒçaå_TestStructs_PintSize
				_e_ƒçaå_TestStructs.Pint = &_p__e_ƒçaå_TestStructs_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_e_ƒçaå_TestStructs.Strs = nil
			} else {
				_n += 1
				__e_ƒçaå_TestStructs_StrsLen, __e_ƒçaå_TestStructs_StrsLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçaå_TestStructs_StrsLenSize
				_e_ƒçaå_TestStructs.Strs = make([]string, __e_ƒçaå_TestStructs_StrsLen)
				for _i := int64(0); _i < __e_ƒçaå_TestStructs_StrsLen; _i++ {
					var _e__e_ƒçaå_TestStructs_Strs string
					__e__e_ƒçaå_TestStructs_StrsLen, __e__e_ƒçaå_TestStructs_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__e_ƒçaå_TestStructs_StrsLenSize
					_e__e_ƒçaå_TestStructs_Strs = string(in[_n : _n+int(__e__e_ƒçaå_TestStructs_StrsLen)])
					_n += int(__e__e_ƒçaå_TestStructs_StrsLen)
					_e_ƒçaå_TestStructs.Strs[_i] = _e__e_ƒçaå_TestStructs_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_e_ƒçaå_TestStructs.StrInt = nil
			} else {
				_n += 1
				__e_ƒçaå_TestStructs_StrIntLen, __e_ƒçaå_TestStructs_StrIntLenSize := binary.Varint(in[_n:])
				_n += __e_ƒçaå_TestStructs_StrIntLenSize
				_e_ƒçaå_TestStructs.StrInt = make(map[string]int, __e_ƒçaå_TestStructs_StrIntLen)
				for _i := int64(0); _i < __e_ƒçaå_TestStructs_StrIntLen; _i++ {
					var _k__e_ƒçaå_TestStructs_StrInt string
					var _v__e_ƒçaå_TestStructs_StrInt int
					__k__e_ƒçaå_TestStructs_StrIntLen, __k__e_ƒçaå_TestStructs_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__e_ƒçaå_TestStructs_StrIntLenSize
					_k__e_ƒçaå_TestStructs_StrInt = string(in[_n : _n+int(__k__e_ƒçaå_TestStructs_StrIntLen)])
					_n += int(__k__e_ƒçaå_TestStructs_StrIntLen)
					__v__e_ƒçaå_TestStructs_StrInt, __v__e_ƒçaå_TestStructs_StrIntSize := binary.Varint(in[_n:])
					_v__e_ƒçaå_TestStructs_StrInt = int(__v__e_ƒçaå_TestStructs_StrInt)
					_n += __v__e_ƒçaå_TestStructs_StrIntSize
					_e_ƒçaå_TestStructs.StrInt[_k__e_ƒçaå_TestStructs_StrInt] = _v__e_ƒçaå_TestStructs_StrInt
				}
			}

			(*a).TestStructs[_i] = _e_ƒçaå_TestStructs
		}
	}
	// StrTestStruct
	if in[_n] == 0 {
		_n += 1
		(*a).StrTestStruct = nil
	} else {
		_n += 1
		_ƒçaå_StrTestStructLen, _ƒçaå_StrTestStructLenSize := binary.Varint(in[_n:])
		_n += _ƒçaå_StrTestStructLenSize
		(*a).StrTestStruct = make(map[string]TestStruct, _ƒçaå_StrTestStructLen)
		for _i := int64(0); _i < _ƒçaå_StrTestStructLen; _i++ {
			var _k_ƒçaå_StrTestStruct string
			var _v_ƒçaå_StrTestStruct TestStruct
			__k_ƒçaå_StrTestStructLen, __k_ƒçaå_StrTestStructLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçaå_StrTestStructLenSize
			_k_ƒçaå_StrTestStruct = string(in[_n : _n+int(__k_ƒçaå_StrTestStructLen)])
			_n += int(__k_ƒçaå_StrTestStructLen)
			// Int
			__v_ƒçaå_StrTestStruct_Int, __v_ƒçaå_StrTestStruct_IntSize := binary.Varint(in[_n:])
			_v_ƒçaå_StrTestStruct.Int = int(__v_ƒçaå_StrTestStruct_Int)
			_n += __v_ƒçaå_StrTestStruct_IntSize
			// Str
			__v_ƒçaå_StrTestStruct_StrLen, __v_ƒçaå_StrTestStruct_StrLenSize := binary.Varint(in[_n:])
			_n += __v_ƒçaå_StrTestStruct_StrLenSize
			_v_ƒçaå_StrTestStruct.Str = string(in[_n : _n+int(__v_ƒçaå_StrTestStruct_StrLen)])
			_n += int(__v_ƒçaå_StrTestStruct_StrLen)
			// Pint
			if in[_n] == 0 {
				_n += 1
				_v_ƒçaå_StrTestStruct.Pint = nil
			} else {
				_n += 1
				var _p__v_ƒçaå_StrTestStruct_Pint int
				__p__v_ƒçaå_StrTestStruct_Pint, __p__v_ƒçaå_StrTestStruct_PintSize := binary.Varint(in[_n:])
				_p__v_ƒçaå_StrTestStruct_Pint = int(__p__v_ƒçaå_StrTestStruct_Pint)
				_n += __p__v_ƒçaå_StrTestStruct_PintSize
				_v_ƒçaå_StrTestStruct.Pint = &_p__v_ƒçaå_StrTestStruct_Pint
			}
			// Strs
			if in[_n] == 0 {
				_n += 1
				_v_ƒçaå_StrTestStruct.Strs = nil
			} else {
				_n += 1
				__v_ƒçaå_StrTestStruct_StrsLen, __v_ƒçaå_StrTestStruct_StrsLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçaå_StrTestStruct_StrsLenSize
				_v_ƒçaå_StrTestStruct.Strs = make([]string, __v_ƒçaå_StrTestStruct_StrsLen)
				for _i := int64(0); _i < __v_ƒçaå_StrTestStruct_StrsLen; _i++ {
					var _e__v_ƒçaå_StrTestStruct_Strs string
					__e__v_ƒçaå_StrTestStruct_StrsLen, __e__v_ƒçaå_StrTestStruct_StrsLenSize := binary.Varint(in[_n:])
					_n += __e__v_ƒçaå_StrTestStruct_StrsLenSize
					_e__v_ƒçaå_StrTestStruct_Strs = string(in[_n : _n+int(__e__v_ƒçaå_StrTestStruct_StrsLen)])
					_n += int(__e__v_ƒçaå_StrTestStruct_StrsLen)
					_v_ƒçaå_StrTestStruct.Strs[_i] = _e__v_ƒçaå_StrTestStruct_Strs
				}
			}
			// StrInt
			if in[_n] == 0 {
				_n += 1
				_v_ƒçaå_StrTestStruct.StrInt = nil
			} else {
				_n += 1
				__v_ƒçaå_StrTestStruct_StrIntLen, __v_ƒçaå_StrTestStruct_StrIntLenSize := binary.Varint(in[_n:])
				_n += __v_ƒçaå_StrTestStruct_StrIntLenSize
				_v_ƒçaå_StrTestStruct.StrInt = make(map[string]int, __v_ƒçaå_StrTestStruct_StrIntLen)
				for _i := int64(0); _i < __v_ƒçaå_StrTestStruct_StrIntLen; _i++ {
					var _k__v_ƒçaå_StrTestStruct_StrInt string
					var _v__v_ƒçaå_StrTestStruct_StrInt int
					__k__v_ƒçaå_StrTestStruct_StrIntLen, __k__v_ƒçaå_StrTestStruct_StrIntLenSize := binary.Varint(in[_n:])
					_n += __k__v_ƒçaå_StrTestStruct_StrIntLenSize
					_k__v_ƒçaå_StrTestStruct_StrInt = string(in[_n : _n+int(__k__v_ƒçaå_StrTestStruct_StrIntLen)])
					_n += int(__k__v_ƒçaå_StrTestStruct_StrIntLen)
					__v__v_ƒçaå_StrTestStruct_StrInt, __v__v_ƒçaå_StrTestStruct_StrIntSize := binary.Varint(in[_n:])
					_v__v_ƒçaå_StrTestStruct_StrInt = int(__v__v_ƒçaå_StrTestStruct_StrInt)
					_n += __v__v_ƒçaå_StrTestStruct_StrIntSize
					_v_ƒçaå_StrTestStruct.StrInt[_k__v_ƒçaå_StrTestStruct_StrInt] = _v__v_ƒçaå_StrTestStruct_StrInt
				}
			}

			(*a).StrTestStruct[_k_ƒçaå_StrTestStruct] = _v_ƒçaå_StrTestStruct
		}
	}

	return _n, nil
}

func (o *OtherPackage) Encode() ([]byte, error) {
	out := make([]byte, o.MaxSize())

	_n, err := o.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (o *OtherPackage) Decode(in []byte) (*OtherPackage, error) {
	_, err := DecodeOtherPackage(in, o)
	if err != nil {
		return o, err
	}

	return o, nil
}

func (o *OtherPackage) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if o != nil {
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*o).Str)
		// TestStruct
		_size += 1 // is nil
		if (*o).TestStruct != nil {
			_size += (*(*o).TestStruct).MaxSize()
		}
		// other
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*o).other {
			_ = _e
			_size += _e.MaxSize()
		}
		// StrAlias
		_size += (*o).StrAlias.MaxSize()
	}
	return _size
}

func (o *OtherPackage) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if o == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Int
		_n += binary.PutVarint(out[_n:], int64((*o).Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*o).Str)))
		_n += copy(out[_n:], (*o).Str)
		// TestStruct
		if (*o).TestStruct == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			ƒçƒçoå_TestStructå, err := (*(*o).TestStruct).EncodeTo(out[_n:])
			if err != nil {
				return 0, err
			}
			_n += ƒçƒçoå_TestStructå
		}
		// other
		if (*o).other == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*o).other)))
			for _, _e := range (*o).other {
				_ = _e
				_e, err := _e.EncodeTo(out[_n:])
				if err != nil {
					return 0, err
				}
				_n += _e
			}
		}
		// StrAlias
		ƒçoå_StrAlias, err := (*o).StrAlias.EncodeTo(out[_n:])
		if err != nil {
			return 0, err
		}
		_n += ƒçoå_StrAlias

	}

	return _n, nil
}

func DecodeOtherPackage(in []byte, o *OtherPackage) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Int
	_ƒçoå_Int, _ƒçoå_IntSize := binary.Varint(in[_n:])
	(*o).Int = int(_ƒçoå_Int)
	_n += _ƒçoå_IntSize
	// Str
	_ƒçoå_StrLen, _ƒçoå_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçoå_StrLenSize
	(*o).Str = string(in[_n : _n+int(_ƒçoå_StrLen)])
	_n += int(_ƒçoå_StrLen)
	// TestStruct
	if in[_n] == 0 {
		_n += 1
		(*o).TestStruct = nil
	} else {
		_n += 1
		var _p_ƒçoå_TestStruct other.TestStruct
		var _e__p_ƒçoå_TestStruct other.TestStruct
		__p_ƒçoå_TestStructSize, err := other.DecodeTestStruct(in[_n:], &_e__p_ƒçoå_TestStruct)
		if err != nil {
			return 0, err
		}
		_p_ƒçoå_TestStruct = _e__p_ƒçoå_TestStruct
		_n += __p_ƒçoå_TestStructSize
		(*o).TestStruct = &_p_ƒçoå_TestStruct
	}
	// other
	if in[_n] == 0 {
		_n += 1
		(*o).other = nil
	} else {
		_n += 1
		_ƒçoå_otherLen, _ƒçoå_otherLenSize := binary.Varint(in[_n:])
		_n += _ƒçoå_otherLenSize
		(*o).other = make([]other.TestStruct, _ƒçoå_otherLen)
		for _i := int64(0); _i < _ƒçoå_otherLen; _i++ {
			var _e_ƒçoå_other other.TestStruct
			var _e__e_ƒçoå_other other.TestStruct
			__e_ƒçoå_otherSize, err := other.DecodeTestStruct(in[_n:], &_e__e_ƒçoå_other)
			if err != nil {
				return 0, err
			}
			_e_ƒçoå_other = _e__e_ƒçoå_other
			_n += __e_ƒçoå_otherSize
			(*o).other[_i] = _e_ƒçoå_other
		}
	}
	// StrAlias
	var _e_ƒçoå_StrAlias example.StrAlias
	_ƒçoå_StrAliasSize, err := example.DecodeStrAlias(in[_n:], &_e_ƒçoå_StrAlias)
	if err != nil {
		return 0, err
	}
	(*o).StrAlias = _e_ƒçoå_StrAlias
	_n += _ƒçoå_StrAliasSize

	return _n, nil
}
