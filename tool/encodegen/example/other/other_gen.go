// Code generated by github.com/yutakahashi114/isutool; DO NOT EDIT.
package other

import (
	"encoding/binary"
	"errors"
	"math"
	"time"
)

var (
	_ = math.MaxUint8
)

func (t *TestStruct) Encode() ([]byte, error) {
	out := make([]byte, t.MaxSize())

	_n, err := t.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (t *TestStruct) Decode(in []byte) (*TestStruct, error) {
	_, err := DecodeTestStruct(in, t)
	if err != nil {
		return t, err
	}

	return t, nil
}

func (t *TestStruct) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if t != nil {
		// Int
		_size += binary.MaxVarintLen64
		// Str
		_size += binary.MaxVarintLen64 + len((*t).Str)
		// Pint
		_size += 1 // is nil
		if (*t).Pint != nil {
			_size += binary.MaxVarintLen64
		}
		// Strs
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _, _e := range (*t).Strs {
			_ = _e
			_size += binary.MaxVarintLen64 + len(_e)
		}
		// StrInt
		_size += binary.MaxVarintLen64
		_size += 1 // is nil
		for _k, _v := range (*t).StrInt {
			_, _ = _k, _v
			_size += binary.MaxVarintLen64 + len(_k)
			_size += binary.MaxVarintLen64
		}
		// Time
		_size += 16
	}
	return _size
}

func (t *TestStruct) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if t == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// Int
		_n += binary.PutVarint(out[_n:], int64((*t).Int))
		// Str
		_n += binary.PutVarint(out[_n:], int64(len((*t).Str)))
		_n += copy(out[_n:], (*t).Str)
		// Pint
		if (*t).Pint == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64((*(*t).Pint)))
		}
		// Strs
		if (*t).Strs == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*t).Strs)))
			for _, _e := range (*t).Strs {
				_ = _e
				_n += binary.PutVarint(out[_n:], int64(len(_e)))
				_n += copy(out[_n:], _e)
			}
		}
		// StrInt
		if (*t).StrInt == nil {
			out[_n] = 0
			_n += 1
		} else {
			out[_n] = 1
			_n += 1
			_n += binary.PutVarint(out[_n:], int64(len((*t).StrInt)))
			for _k, _v := range (*t).StrInt {
				_, _ = _k, _v
				_n += binary.PutVarint(out[_n:], int64(len(_k)))
				_n += copy(out[_n:], _k)
				_n += binary.PutVarint(out[_n:], int64(_v))
			}
		}
		// Time
		ƒçtå_Time, err := _timeMarshalBinary((*t).Time, out[_n:])
		if err != nil {
			return 0, err
		}
		_n += ƒçtå_Time

	}

	return _n, nil
}

func DecodeTestStruct(in []byte, t *TestStruct) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// Int
	_ƒçtå_Int, _ƒçtå_IntSize := binary.Varint(in[_n:])
	(*t).Int = int(_ƒçtå_Int)
	_n += _ƒçtå_IntSize
	// Str
	_ƒçtå_StrLen, _ƒçtå_StrLenSize := binary.Varint(in[_n:])
	_n += _ƒçtå_StrLenSize
	(*t).Str = string(in[_n : _n+int(_ƒçtå_StrLen)])
	_n += int(_ƒçtå_StrLen)
	// Pint
	if in[_n] == 0 {
		_n += 1
		(*t).Pint = nil
	} else {
		_n += 1
		var _p_ƒçtå_Pint int
		__p_ƒçtå_Pint, __p_ƒçtå_PintSize := binary.Varint(in[_n:])
		_p_ƒçtå_Pint = int(__p_ƒçtå_Pint)
		_n += __p_ƒçtå_PintSize
		(*t).Pint = &_p_ƒçtå_Pint
	}
	// Strs
	if in[_n] == 0 {
		_n += 1
		(*t).Strs = nil
	} else {
		_n += 1
		_ƒçtå_StrsLen, _ƒçtå_StrsLenSize := binary.Varint(in[_n:])
		_n += _ƒçtå_StrsLenSize
		(*t).Strs = make([]string, _ƒçtå_StrsLen)
		for _i := int64(0); _i < _ƒçtå_StrsLen; _i++ {
			var _e_ƒçtå_Strs string
			__e_ƒçtå_StrsLen, __e_ƒçtå_StrsLenSize := binary.Varint(in[_n:])
			_n += __e_ƒçtå_StrsLenSize
			_e_ƒçtå_Strs = string(in[_n : _n+int(__e_ƒçtå_StrsLen)])
			_n += int(__e_ƒçtå_StrsLen)
			(*t).Strs[_i] = _e_ƒçtå_Strs
		}
	}
	// StrInt
	if in[_n] == 0 {
		_n += 1
		(*t).StrInt = nil
	} else {
		_n += 1
		_ƒçtå_StrIntLen, _ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
		_n += _ƒçtå_StrIntLenSize
		(*t).StrInt = make(map[string]int, _ƒçtå_StrIntLen)
		for _i := int64(0); _i < _ƒçtå_StrIntLen; _i++ {
			var _k_ƒçtå_StrInt string
			var _v_ƒçtå_StrInt int
			__k_ƒçtå_StrIntLen, __k_ƒçtå_StrIntLenSize := binary.Varint(in[_n:])
			_n += __k_ƒçtå_StrIntLenSize
			_k_ƒçtå_StrInt = string(in[_n : _n+int(__k_ƒçtå_StrIntLen)])
			_n += int(__k_ƒçtå_StrIntLen)
			__v_ƒçtå_StrInt, __v_ƒçtå_StrIntSize := binary.Varint(in[_n:])
			_v_ƒçtå_StrInt = int(__v_ƒçtå_StrInt)
			_n += __v_ƒçtå_StrIntSize
			(*t).StrInt[_k_ƒçtå_StrInt] = _v_ƒçtå_StrInt
		}
	}
	// Time
	if in[_n] == 1 {
		err = (*t).Time.UnmarshalBinary(in[_n : _n+15])
	} else {
		err = (*t).Time.UnmarshalBinary(in[_n : _n+16])
	}
	if err != nil {
		return 0, err
	}
	_n += 16

	return _n, nil
}
